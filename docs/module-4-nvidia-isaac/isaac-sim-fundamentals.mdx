---
sidebar_position: 16
title: Chapter 4.1 - Isaac Sim Fundamentals
description: NVIDIA Isaac Sim Architecture and Usage
---

# Chapter 4.1: Isaac Sim Fundamentals

## Goal
Learn the core concepts of Isaac Sim for advanced humanoid simulation.

## Learning Outcomes
After completing this chapter, students will understand and implement Isaac Sim for humanoid robot simulation.

## Introduction

NVIDIA Isaac Sim represents a significant advancement in robotics simulation, providing a comprehensive platform that combines high-fidelity physics simulation with photorealistic rendering. Built on NVIDIA's Omniverse platform, Isaac Sim enables the creation of complex, realistic environments for testing and training humanoid robots. This chapter introduces the fundamental concepts, architecture, and usage patterns essential for leveraging Isaac Sim in humanoid robotics applications.

## Isaac Sim Architecture

### Core Components

Isaac Sim is built on several key components that work together to provide a powerful simulation environment:

1. **Omniverse Platform**: The underlying foundation that provides real-time collaboration, USD-based scene description, and extensible architecture
2. **PhysX Physics Engine**: NVIDIA's advanced physics simulation engine optimized for robotics applications
3. **RTX Rendering**: Real-time ray tracing for photorealistic visuals
4. **Isaac Extensions**: Specialized tools and frameworks for robotics applications
5. **ROS 2 Bridge**: Seamless integration with ROS 2 for robotics development workflows

### Omniverse and USD Integration

Isaac Sim leverages NVIDIA Omniverse and Universal Scene Description (USD) as its core technologies:

- **USD (Universal Scene Description)**: A scalable scene description composed of asset interchange and composition formats
- **MDL (Material Description Language)**: For physically-based material definitions
- **RTX Real-time Ray Tracing**: For photorealistic rendering and sensor simulation
- **PhysX**: For accurate physics simulation

## Setting Up Isaac Sim

### Installation and Prerequisites

Isaac Sim has specific hardware and software requirements:

#### Hardware Requirements
- **GPU**: NVIDIA RTX series (RTX 3080 or better recommended)
- **VRAM**: 10GB+ recommended for complex humanoid scenes
- **CPU**: Multi-core processor (8+ cores)
- **RAM**: 32GB+ recommended
- **Storage**: SSD with 100GB+ available space

#### Software Requirements
- **CUDA**: 11.8 or later
- **NVIDIA Driver**: 520 or later
- **Isaac Sim**: Available via NVIDIA NGC or standalone installer

### Installation Methods

#### Method 1: Isaac Sim Docker (Recommended)
```bash
# Pull the Isaac Sim Docker image
docker pull nvcr.io/nvidia/isaac-sim:4.0.0

# Run Isaac Sim container
docker run --gpus all -it --rm \
  --network=host \
  --env "DISPLAY" \
  --env "QT_X11_NO_MITSHM=1" \
  --volume "/tmp/.X11-unix:/tmp/.X11-unix:rw" \
  --volume "/home/$USER/Documents/IsaacSim/projects:/isaac-sim/projects" \
  --privileged \
  --pid=host \
  nvcr.io/nvidia/isaac-sim:4.0.0
```

#### Method 2: Isaac Sim Standalone
- Download from NVIDIA Developer website
- Install using Omniverse Launcher
- Configure extensions and assets

## Isaac Sim Python API

### Basic Scene Setup

```python
import omni
from omni.isaac.core import World
from omni.isaac.core.utils.stage import add_reference_to_stage
from omni.isaac.core.utils.nucleus import get_assets_root_path
from omni.isaac.core.robots import Robot
from omni.isaac.core.articulations import Articulation

# Initialize Isaac Sim
def setup_world():
    """Create and configure the simulation world"""
    # Create world instance
    world = World(stage_units_in_meters=1.0)

    # Set default physics parameters
    world.get_physics_context().set_gravity(9.81)
    world.get_physics_context().set_simulation_dt(1.0/60.0, substeps=1)

    return world

def create_basic_scene():
    """Create a basic scene with ground plane and lighting"""
    world = setup_world()

    # Get assets root path
    assets_root_path = get_assets_root_path()

    # Add ground plane
    add_reference_to_stage(
        assets_root_path + "/Isaac/Environments/Grid/default_environment.usd",
        "/World/defaultGround"
    )

    # Add simple room environment
    add_reference_to_stage(
        assets_root_path + "/Isaac/Environments/Simple_Room/simple_room.usd",
        "/World/Room"
    )

    return world
```

### Robot Loading and Configuration

```python
from omni.isaac.core.utils.stage import add_reference_to_stage
from omni.isaac.core.robots import Robot
from omni.isaac.core.articulations import Articulation

class IsaacSimHumanoidRobot:
    def __init__(self, prim_path, usd_path, position=[0, 0, 1.0], orientation=[0, 0, 0, 1]):
        self.prim_path = prim_path
        self.usd_path = usd_path
        self.position = position
        self.orientation = orientation
        self.robot = None

    def load_robot(self):
        """Load humanoid robot from USD file"""
        # Add robot reference to stage
        add_reference_to_stage(
            usd_path=self.usd_path,
            prim_path=self.prim_path
        )

        # Create robot object
        self.robot = Robot(
            prim_path=self.prim_path,
            name=self.prim_path.split("/")[-1],
            position=self.position,
            orientation=self.orientation
        )

        return self.robot

    def setup_controllers(self):
        """Setup joint controllers for the humanoid robot"""
        # Get joint names
        joint_names = self.robot.dof_names

        # Initialize joint controllers
        self.joint_controllers = {}
        for joint_name in joint_names:
            # Create position controller for each joint
            self.joint_controllers[joint_name] = {
                'target_position': 0.0,
                'current_position': 0.0,
                'max_effort': 100.0,
                'control_mode': 'position'
            }

    def move_to_position(self, joint_positions):
        """Move robot joints to specified positions"""
        if self.robot:
            # Set joint positions
            self.robot.set_joints_state(positions=joint_positions)

    def get_robot_state(self):
        """Get current state of the robot"""
        if self.robot:
            joint_positions = self.robot.get_joints_state().position
            joint_velocities = self.robot.get_joints_state().velocity
            base_position, base_orientation = self.robot.get_world_pose()

            return {
                'joint_positions': joint_positions,
                'joint_velocities': joint_velocities,
                'base_position': base_position,
                'base_orientation': base_orientation
            }
        return None
```

### Physics Configuration for Humanoid Robots

```python
from pxr import PhysxSchema, UsdPhysics, Gf
from omni.isaac.core.utils.prims import get_prim_at_path

def configure_humanoid_physics(robot_prim_path, robot_mass=75.0):
    """Configure physics properties for humanoid robot"""

    # Get robot prim
    robot_prim = get_prim_at_path(robot_prim_path)

    # Enable rigid body dynamics for the robot
    rigid_body_api = UsdPhysics.RigidBodyAPI.Apply(robot_prim)
    rigid_body_api.CreateRigidBodyEnabledAttr(True)

    # Configure PhysX properties for stability
    physx_rigid_body_api = PhysxSchema.PhysxRigidBodyAPI.Apply(robot_prim)
    physx_rigid_body_api.CreateSleepThresholdAttr(0.001)
    physx_rigid_body_api.CreateStabilizationThresholdAttr(0.001)

    # Configure mass properties for each link
    configure_link_masses(robot_prim_path, robot_mass)

    # Configure joint properties for stability
    configure_joint_properties(robot_prim_path)

def configure_link_masses(robot_prim_path, total_mass):
    """Distribute mass across humanoid links based on anatomical proportions"""
    # Anatomical mass distribution for humanoid
    mass_distribution = {
        'pelvis': 0.12,      # 12% of body mass
        'torso': 0.35,       # 35% of body mass
        'head': 0.07,        # 7% of body mass
        'upper_leg_l': 0.10, # 10% each leg
        'lower_leg_l': 0.05, # 5% each lower leg
        'foot_l': 0.015,     # 1.5% each foot
        'upper_arm_l': 0.03, # 3% each arm
        'lower_arm_l': 0.015 # 1.5% each lower arm
    }

    # Apply to all links
    for link_name, mass_ratio in mass_distribution.items():
        link_path = f"{robot_prim_path}/{link_name}"
        link_prim = get_prim_at_path(link_path)

        if link_prim:
            mass_api = UsdPhysics.MassAPI.Apply(link_prim)
            link_mass = total_mass * mass_ratio
            mass_api.CreateMassAttr(link_mass)

            # Set center of mass
            mass_api.CreateCenterOfMassAttr(Gf.Vec3f(0, 0, 0))

def configure_joint_properties(robot_prim_path):
    """Configure joint properties for humanoid stability"""
    # Joint limits and damping for humanoid joints
    joint_config = {
        # Hip joints
        'left_hip_yaw': {'lower': -0.52, 'upper': 0.52, 'damping': 1.0},
        'left_hip_roll': {'lower': -0.52, 'upper': 0.52, 'damping': 1.0},
        'left_hip_pitch': {'lower': -1.57, 'upper': 0.78, 'damping': 2.0},

        # Knee joints
        'left_knee': {'lower': 0.0, 'upper': 2.26, 'damping': 2.0},

        # Ankle joints
        'left_ankle_pitch': {'lower': -0.52, 'upper': 0.52, 'damping': 0.5},
        'left_ankle_roll': {'lower': -0.52, 'upper': 0.52, 'damping': 0.5},

        # Shoulder joints
        'left_shoulder_pitch': {'lower': -2.09, 'upper': 2.09, 'damping': 0.5},
        'left_shoulder_yaw': {'lower': -1.57, 'upper': 1.57, 'damping': 0.5},
        'left_shoulder_roll': {'lower': -3.14, 'upper': 1.57, 'damping': 0.5},

        # Elbow joints
        'left_elbow': {'lower': 0.0, 'upper': 2.61, 'damping': 0.5}
    }

    for joint_name, config in joint_config.items():
        joint_path = f"{robot_prim_path}/{joint_name}"
        joint_prim = get_prim_at_path(joint_path)

        if joint_prim:
            # Set joint limits
            physx_joint_api = PhysxSchema.PhysxJointAPI(joint_prim)
            physx_joint_api.CreateLowerLimitAttr(config['lower'])
            physx_joint_api.CreateUpperLimitAttr(config['upper'])

            # Set damping
            physx_joint_api.CreateJointLinearLimitAttr(config['damping'])
```

## Environment Creation for Humanoid Robots

### Basic Environment Setup

```python
def create_humanoid_training_environment():
    """Create an environment suitable for humanoid robot training"""
    world = World(stage_units_in_meters=1.0)

    # Create ground plane
    add_reference_to_stage(
        get_assets_root_path() + "/Isaac/Environments/Grid/default_environment.usd",
        "/World/defaultGround"
    )

    # Add varied terrain for locomotion training
    create_varied_terrain("/World/Terrain")

    # Add obstacles for navigation
    create_obstacles("/World/Obstacles")

    # Add interactive objects
    create_interactive_objects("/World/Objects")

    return world

def create_varied_terrain(terrain_path):
    """Create terrain with different surfaces for humanoid training"""
    # Flat ground
    add_reference_to_stage(
        get_assets_root_path() + "/Isaac/Environments/Grid/default_environment.usd",
        f"{terrain_path}/FlatGround"
    )

    # Uneven terrain
    add_reference_to_stage(
        get_assets_root_path() + "/Isaac/Props/Obstacles/uneven_ground.usd",
        f"{terrain_path}/UnevenGround"
    )

    # Stairs
    add_reference_to_stage(
        get_assets_root_path() + "/Isaac/Props/Obstacles/stairs.usd",
        f"{terrain_path}/Stairs"
    )

    # Slopes
    add_reference_to_stage(
        get_assets_root_path() + "/Isaac/Props/Obstacles/slope.usd",
        f"{terrain_path}/Slope"
    )

def create_obstacles(obstacles_path):
    """Create obstacles for humanoid navigation"""
    obstacle_configs = [
        {"type": "box", "position": [2, 0, 0.5]},
        {"type": "cylinder", "position": [-2, 1, 0.5]},
        {"type": "sphere", "position": [0, -2, 0.5]}
    ]

    for i, config in enumerate(obstacle_configs):
        if config["type"] == "box":
            add_reference_to_stage(
                get_assets_root_path() + "/Isaac/Props/Obstacles/box.usd",
                f"{obstacles_path}/Box_{i}"
            )
        elif config["type"] == "cylinder":
            add_reference_to_stage(
                get_assets_root_path() + "/Isaac/Props/Obstacles/cylinder.usd",
                f"{obstacles_path}/Cylinder_{i}"
            )
        elif config["type"] == "sphere":
            add_reference_to_stage(
                get_assets_root_path() + "/Isaac/Props/Obstacles/sphere.usd",
                f"{obstacles_path}/Sphere_{i}"
            )
```

### Advanced Environment Features

```python
class DynamicEnvironment:
    def __init__(self, world):
        self.world = world
        self.movable_objects = []
        self.dynamic_lights = []

    def add_movable_object(self, usd_path, position, mass=1.0):
        """Add a movable object to the environment"""
        obj_path = f"/World/MovableObj_{len(self.movable_objects)}"

        add_reference_to_stage(usd_path, obj_path)

        # Set position
        from omni.isaac.core.utils.prims import set_world_translation
        set_world_translation(position, obj_path)

        # Configure physics
        obj_prim = get_prim_at_path(obj_path)
        rigid_body_api = UsdPhysics.RigidBodyAPI.Apply(obj_prim)
        rigid_body_api.CreateRigidBodyEnabledAttr(True)

        # Set mass
        mass_api = UsdPhysics.MassAPI.Apply(obj_prim)
        mass_api.CreateMassAttr(mass)

        self.movable_objects.append(obj_path)

    def add_dynamic_lighting(self, position, intensity=1000):
        """Add dynamic lighting that can be modified during simulation"""
        light_path = f"/World/DynamicLight_{len(self.dynamic_lights)}"

        # Create light prim
        stage = omni.usd.get_context().get_stage()
        light_prim = stage.DefinePrim(light_path, "DistantLight")
        light_prim.GetAttribute("xformOp:translate").Set(position)
        light_prim.GetAttribute("inputs:intensity").Set(intensity)

        self.dynamic_lights.append(light_path)

    def randomize_environment(self):
        """Randomize environment properties for domain randomization"""
        # Randomize object positions
        for obj_path in self.movable_objects:
            new_pos = [
                random.uniform(-5, 5),
                random.uniform(-5, 5),
                random.uniform(0.5, 2.0)
            ]
            from omni.isaac.core.utils.prims import set_world_translation
            set_world_translation(new_pos, obj_path)

        # Randomize lighting
        for light_path in self.dynamic_lights:
            light_prim = get_prim_at_path(light_path)
            new_intensity = random.uniform(500, 2000)
            light_prim.GetAttribute("inputs:intensity").Set(new_intensity)
```

## Sensor Integration in Isaac Sim

### Camera Sensors

Isaac Sim provides high-quality camera simulation with various configurations:

```python
from omni.isaac.sensor import Camera
import numpy as np

class IsaacSimCamera:
    def __init__(self, prim_path, config):
        self.camera = Camera(
            prim_path=prim_path,
            frequency=config.get("frequency", 30),
            resolution=(config["width"], config["height"])
        )

        # Configure camera intrinsic parameters
        self.camera.focal_length = config.get("focal_length", 24.0)
        self.camera.focus_distance = config.get("focus_distance", 10.0)
        self.camera.f_stop = config.get("f_stop", 0.0)  # 0.0 = disabled

        # Enable different sensor types
        self.sensor_types = []
        if config.get("rgb", True):
            self.camera.add_render_product("rgb")
            self.sensor_types.append("rgb")

        if config.get("depth", False):
            self.camera.add_render_product("depth")
            self.sensor_types.append("depth")

        if config.get("semantic", False):
            self.camera.add_render_product("semantic_segmentation")
            self.sensor_types.append("semantic")

        if config.get("instance", False):
            self.camera.add_render_product("instance_segmentation")
            self.sensor_types.append("instance")

    def get_observation(self):
        """Get sensor observation data"""
        observation = {}

        if "rgb" in self.sensor_types:
            observation["rgb"] = self.camera.get_rgb()

        if "depth" in self.sensor_types:
            observation["depth"] = self.camera.get_depth()

        if "semantic" in self.sensor_types:
            observation["semantic"] = self.camera.get_semantic_segmentation()

        if "instance" in self.sensor_types:
            observation["instance"] = self.camera.get_instance_segmentation()

        return observation

    def get_pose(self):
        """Get camera pose in world coordinates"""
        return self.camera.get_world_pose()

# Example usage
camera_config = {
    "width": 640,
    "height": 480,
    "frequency": 30,
    "focal_length": 24.0,
    "rgb": True,
    "depth": True,
    "semantic": True
}

head_camera = IsaacSimCamera("/World/Robot/head_camera", camera_config)
```

### LIDAR and Other Sensors

```python
from omni.isaac.range_sensor import LidarRtx

class IsaacSimLidar:
    def __init__(self, prim_path, config):
        self.lidar = LidarRtx(
            prim_path=prim_path,
            translation=config.get("position", (0, 0, 0)),
            orientation=config.get("orientation", (0, 0, 0, 1)),
            config_file_name=config.get("config_file", "Example_Rotary_Lidar"),
            # Custom configuration
            rotation_frequency=config.get("rotation_freq", 10),
            channels=config.get("channels", 16),
            points_per_channel=config.get("points_per_channel", 1000),
            horizontal_resolution=config.get("horizontal_resolution", 0.1875),
            vertical_resolution=config.get("vertical_resolution", 2.0),
            horizontal_laser_angle=config.get("horizontal_angle", 360.0),
            vertical_laser_angle=config.get("vertical_angle", 30.0),
            max_range=config.get("max_range", 25.0),
            min_range=config.get("min_range", 0.1),
        )

    def get_point_cloud(self):
        """Get 3D point cloud from LIDAR"""
        return self.lidar.get_point_cloud()

    def get_ranges(self):
        """Get distance measurements"""
        return self.lidar.get_linear_depth_data()

    def get_pose(self):
        """Get LIDAR pose"""
        return self.lidar.get_world_pose()

# Create LIDAR sensor for humanoid robot
lidar_config = {
    "position": (0, 0, 1.5),  # On robot's head
    "channels": 32,
    "points_per_channel": 2048,
    "max_range": 25.0
}

robot_lidar = IsaacSimLidar("/World/Robot/lidar", lidar_config)
```

## Simulation Control and Execution

### World Management

```python
class IsaacSimWorldManager:
    def __init__(self):
        self.world = None
        self.robots = []
        self.sensors = []

    def setup_world(self, stage_units_in_meters=1.0):
        """Initialize the simulation world"""
        self.world = World(stage_units_in_meters=stage_units_in_meters)

        # Configure physics
        physics_ctx = self.world.get_physics_context()
        physics_ctx.set_gravity(9.81)
        physics_ctx.set_simulation_dt(1.0/60.0, substeps=1)

        # Enable GPU dynamics if available
        try:
            physics_ctx.enable_gpu_dynamics(True)
            physics_ctx.set_broadphase_type("GPU")
        except:
            print("GPU dynamics not available, using CPU")

        return self.world

    def add_robot(self, robot):
        """Add robot to the simulation"""
        self.robots.append(robot)

    def reset_world(self):
        """Reset the entire simulation world"""
        if self.world:
            self.world.reset()

            # Reset all robots
            for robot in self.robots:
                robot.reset()

    def run_simulation(self, num_steps=1000, render=True):
        """Run the simulation for specified steps"""
        for step in range(num_steps):
            # Update robots
            for robot in self.robots:
                robot.update()

            # Step the physics simulation
            self.world.step(render=render)

            # Check for termination conditions
            if self.check_termination():
                break

    def check_termination(self):
        """Check if simulation should terminate"""
        # Implement termination conditions
        return False

    def get_simulation_state(self):
        """Get current state of the entire simulation"""
        state = {
            'time': self.world.current_time_step_index,
            'robots': [robot.get_state() for robot in self.robots],
            'sensors': [sensor.get_data() for sensor in self.sensors]
        }
        return state
```

### Humanoid-Specific Simulation Features

```python
class HumanoidSimulationController:
    def __init__(self, world, robot):
        self.world = world
        self.robot = robot
        self.balance_controller = BalanceController()
        self.locomotion_controller = LocomotionController()

    def setup_balance_control(self):
        """Setup balance control for humanoid robot"""
        # Initialize balance controller with robot parameters
        self.balance_controller.initialize(
            robot_mass=self.robot.get_mass(),
            com_height=self.robot.get_com_height()
        )

    def apply_balance_control(self):
        """Apply balance control to maintain humanoid stability"""
        # Get current robot state
        robot_state = self.robot.get_state()

        # Calculate balance corrections
        balance_corrections = self.balance_controller.compute_control(robot_state)

        # Apply corrections to robot
        self.robot.apply_joint_torques(balance_corrections)

    def setup_locomotion(self, gait_type='walk'):
        """Setup locomotion controller for humanoid movement"""
        self.locomotion_controller.setup_gait(gait_type)

    def execute_locomotion_step(self):
        """Execute one step of locomotion"""
        # Get desired locomotion command
        desired_velocity = self.locomotion_controller.get_desired_velocity()

        # Generate joint trajectories
        joint_trajectories = self.locomotion_controller.generate_trajectories(
            self.robot.get_state(), desired_velocity
        )

        # Apply to robot
        self.robot.set_joint_trajectories(joint_trajectories)

    def run_humanoid_behavior(self, behavior_type):
        """Run specific humanoid behavior"""
        if behavior_type == 'walk':
            self.setup_locomotion('walk')
            self.execute_locomotion_step()
            self.apply_balance_control()
        elif behavior_type == 'balance':
            self.apply_balance_control()
        elif behavior_type == 'manipulate':
            # Implement manipulation behavior
            pass
```

## Best Practices for Isaac Sim

### Performance Optimization

```python
def optimize_simulation_performance(world):
    """Optimize Isaac Sim performance for humanoid applications"""

    # Physics optimization
    physics_ctx = world.get_physics_context()

    # Use appropriate substeps for stability vs performance
    physics_ctx.set_simulation_dt(1.0/60.0, substeps=2)

    # Enable multithreading
    physics_ctx.enable_multithreading(True)

    # Use GPU dynamics if available
    try:
        physics_ctx.enable_gpu_dynamics(True)
        physics_ctx.set_broadphase_type("GPU")
    except:
        pass  # GPU dynamics not available

    # Rendering optimization
    # Reduce resolution for training phases
    # Use simpler materials and lighting
    # Implement frustum culling for cameras

def setup_humanoid_simulation_optimally(robot_path):
    """Setup humanoid simulation with optimal parameters"""

    # Create world with appropriate units
    world = World(stage_units_in_meters=1.0)

    # Configure physics for humanoid stability
    physics_ctx = world.get_physics_context()
    physics_ctx.set_simulation_dt(1.0/120.0, substeps=2)  # Higher frequency for humanoid
    physics_ctx.set_gravity(-9.81)

    # Enable GPU dynamics for complex humanoid simulation
    try:
        physics_ctx.enable_gpu_dynamics(True)
        physics_ctx.set_broadphase_type("GPU")
    except:
        print("Using CPU dynamics")

    # Load robot with optimized parameters
    robot = Robot(prim_path=robot_path)

    return world, robot
```

### Model Quality and Validation

- Use accurate mass properties for realistic physics
- Implement proper joint limits and friction models
- Validate simulation against real-world robot specifications
- Test with various environmental conditions

## Troubleshooting Common Issues

### Physics Instability

```python
def fix_physics_instability(robot_prim_path):
    """Fix common physics instability issues in humanoid robots"""

    # Increase joint damping
    for joint_name in ['hip', 'knee', 'ankle', 'shoulder', 'elbow']:
        joint_path = f"{robot_prim_path}/{joint_name}_joint"
        joint_prim = get_prim_at_path(joint_path)

        if joint_prim:
            physx_joint_api = PhysxSchema.PhysxJointAPI(joint_prim)
            # Increase damping to stabilize joints
            physx_joint_api.CreateJointLinearLimitAttr(2.0)
```

### Rendering Performance

- Reduce resolution during training
- Use simplified materials and lighting
- Implement level-of-detail (LOD) systems
- Use occlusion culling for large environments

## Summary

Isaac Sim provides a powerful platform for humanoid robotics simulation with high-fidelity physics and photorealistic rendering. Understanding the core architecture, proper configuration, and optimization techniques is essential for effective simulation. The combination of USD-based scene description, PhysX physics, and RTX rendering makes Isaac Sim ideal for developing and testing complex humanoid robot behaviors.

## Exercises

1. Create a humanoid robot model in Isaac Sim with proper physics configuration
2. Implement a camera system with RGB, depth, and semantic segmentation
3. Set up a varied terrain environment for humanoid locomotion training
4. Optimize the simulation for real-time performance with a complex humanoid model

## References

[1] NVIDIA, "Isaac Sim Documentation," NVIDIA Corporation, 2023.

[2] NVIDIA, "Omniverse Platform Overview," NVIDIA Corporation, 2023.

[3] A. To et al., "Advanced Robotics Simulation with Isaac Sim," NVIDIA Technical Report, 2022.