---
sidebar_position: 6
title: Chapter 2.1 - ROS 2 Architecture and Concepts
description: Nodes, Topics, Services, and Actions in ROS 2
---

# Chapter 2.1: ROS 2 Architecture and Concepts

## Goal
Master the fundamental ROS 2 concepts essential for humanoid robotics development.

## Learning Outcomes
After completing this chapter, students will be able to design and implement basic ROS 2 nodes and communication patterns.

## Introduction

Robot Operating System 2 (ROS 2) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms. Understanding ROS 2 architecture is fundamental for humanoid robotics development.

## ROS 2 Architecture Overview

ROS 2 uses a distributed architecture where processes (called "nodes") communicate with each other through messages. This architecture is built on top of DDS (Data Distribution Service), which provides the underlying communication infrastructure.

### Key Components

1. **Nodes**: Processes that perform computation
2. **Topics**: Named buses over which nodes exchange messages
3. **Services**: Synchronous request/response communication
4. **Actions**: Asynchronous request/goal-based communication
5. **Parameters**: Configuration values accessible to nodes
6. **Launch files**: Configuration for starting multiple nodes

## Nodes

Nodes are the fundamental building blocks of ROS 2 applications. Each node is a separate process that performs a specific task and communicates with other nodes through messages.

### Creating a Node

In ROS 2, nodes are created by inheriting from the `Node` class provided by the client library (rclpy for Python, rclcpp for C++).

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Hello from minimal node!')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Node Names and Namespaces

Each node must have a unique name within the ROS graph. Nodes can also be organized using namespaces to avoid naming conflicts.

## Topics and Publishers/Subscribers

Topics enable asynchronous communication between nodes through a publish/subscribe pattern. Publishers send messages to a topic, and subscribers receive messages from that topic.

### Publisher Example

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1
```

### Subscriber Example

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)
```

### Quality of Service (QoS) Settings

QoS settings control how messages are delivered between publishers and subscribers, affecting reliability, durability, and performance.

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy

qos_profile = QoSProfile(
    depth=10,
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.VOLATILE
)
```

## Services

Services provide synchronous request/response communication between nodes. A service client sends a request to a service server, which processes the request and returns a response.

### Service Server Example

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))
        return response
```

### Service Client Example

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalClient(Node):
    def __init__(self):
        super().__init__('minimal_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()
```

## Actions

Actions are used for long-running tasks that may send feedback and can be canceled. They follow a goal-result-feedback pattern.

### Action Server Example

```python
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])

            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info('Returning result: {0}'.format(result.sequence))
        return result
```

## Parameters

Parameters allow nodes to be configured at runtime. They can be set when launching nodes or changed during runtime.

```python
# Declare a parameter
self.declare_parameter('param_name', 'default_value')

# Get a parameter value
param_value = self.get_parameter('param_name').value

# Set a parameter
self.set_parameter('param_name', 'new_value')
```

## Launch Files

Launch files allow you to start multiple nodes with a single command and configure their parameters.

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_package',
            executable='my_node',
            name='my_node_name',
            parameters=[
                {'param1': 'value1'},
                {'param2': 123}
            ]
        )
    ])
```

## ROS 2 for Humanoid Robotics

In humanoid robotics, ROS 2 provides the communication infrastructure that connects different subsystems:

- **Perception nodes**: Processing sensor data (cameras, LIDAR, IMU)
- **Control nodes**: Managing joint positions, balance, and locomotion
- **Planning nodes**: Path planning and motion planning
- **Behavior nodes**: High-level decision making and task execution

### Example: Humanoid Robot Node Structure

```
Humanoid Robot System
├── Perception System
│   ├── Vision Processing
│   ├── IMU Processing
│   └── Force/Torque Sensors
├── Control System
│   ├── Joint Control
│   ├── Balance Control
│   └── Locomotion Control
├── Planning System
│   ├── Path Planning
│   ├── Motion Planning
│   └── Task Planning
└── Interface System
    ├── Human-Robot Interaction
    └── Remote Control
```

## Best Practices for ROS 2 Development

### Node Design
- Keep nodes focused on a single responsibility
- Use appropriate QoS settings for different message types
- Implement proper error handling and logging
- Design for reusability and modularity

### Message Design
- Use standard message types when possible
- Design messages for efficiency (avoid large messages on fast topics)
- Consider the frequency of message publication
- Use appropriate data types for precision and efficiency

### System Architecture
- Plan the communication architecture before implementation
- Use namespaces to organize related nodes
- Consider network topology and bandwidth constraints
- Implement proper testing and debugging strategies

## Summary

ROS 2 provides the foundational communication architecture for humanoid robotics. Understanding nodes, topics, services, actions, and parameters is essential for building complex robotic systems. The distributed nature of ROS 2 enables the modular design of humanoid robot systems, where different components can be developed and tested independently.

## Exercises

1. Create a simple publisher-subscriber pair that communicates joint position commands
2. Implement a service that calculates the forward kinematics for a simple arm
3. Design a launch file for a humanoid robot with perception, control, and planning nodes

## References

[1] M. Quigley et al., "ROS: an open-source Robot Operating System," ICRA Workshop on Open Source Software, 2009.

[2] ROS 2 Documentation, "Concepts Overview," https://docs.ros.org/en/rolling/Concepts.html

[3] S. Chitta et al., "ROS Industrial: Advanced capabilities for manufacturing," ISER, 2012.