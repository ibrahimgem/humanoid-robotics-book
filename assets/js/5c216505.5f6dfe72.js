"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[1994],{28453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>s});var i=a(96540);const o={},t=i.createContext(o);function r(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(t.Provider,{value:e},n.children)}},98121:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>_,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-4-nvidia-isaac/nav2-navigation-system","title":"Chapter 4.3 - Nav2 Navigation System","description":"Navigation Stack for Humanoid Robots","source":"@site/docs/module-4-nvidia-isaac/nav2-navigation-system.mdx","sourceDirName":"module-4-nvidia-isaac","slug":"/module-4-nvidia-isaac/nav2-navigation-system","permalink":"/humanoid-robotics-book/docs/module-4-nvidia-isaac/nav2-navigation-system","draft":false,"unlisted":false,"editUrl":"https://github.com/ibrahimgem/humanoid-robotics-book/edit/main/docs/module-4-nvidia-isaac/nav2-navigation-system.mdx","tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18,"title":"Chapter 4.3 - Nav2 Navigation System","description":"Navigation Stack for Humanoid Robots"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4.2 - Isaac ROS Integration","permalink":"/humanoid-robotics-book/docs/module-4-nvidia-isaac/isaac-ros-integration"},"next":{"title":"Chapter 4.4 - Isaac Extensions and Tools","permalink":"/humanoid-robotics-book/docs/module-4-nvidia-isaac/isaac-extensions-tools"}}');var o=a(74848),t=a(28453);const r={sidebar_position:18,title:"Chapter 4.3 - Nav2 Navigation System",description:"Navigation Stack for Humanoid Robots"},s="Chapter 4.3: Nav2 Navigation System",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Nav2 Architecture Overview",id:"nav2-architecture-overview",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Behavior-Based Architecture",id:"behavior-based-architecture",level:3},{value:"Navigation States",id:"navigation-states",level:3},{value:"Nav2 Configuration for Humanoid Robots",id:"nav2-configuration-for-humanoid-robots",level:2},{value:"Parameter Configuration",id:"parameter-configuration",level:3},{value:"Humanoid-Specific Navigation Parameters",id:"humanoid-specific-navigation-parameters",level:3},{value:"Path Planning for Humanoid Robots",id:"path-planning-for-humanoid-robots",level:2},{value:"Global Path Planning",id:"global-path-planning",level:3},{value:"Local Path Planning and Obstacle Avoidance",id:"local-path-planning-and-obstacle-avoidance",level:3},{value:"Navigation Controllers for Humanoid Robots",id:"navigation-controllers-for-humanoid-robots",level:2},{value:"Humanoid-Aware Trajectory Controller",id:"humanoid-aware-trajectory-controller",level:3},{value:"Footstep Planning for Humanoid Navigation",id:"footstep-planning-for-humanoid-navigation",level:3},{value:"Integration with Isaac Sim Navigation",id:"integration-with-isaac-sim-navigation",level:2},{value:"Isaac Sim Navigation Setup",id:"isaac-sim-navigation-setup",level:3},{value:"Navigation in Simulation",id:"navigation-in-simulation",level:3},{value:"Recovery Behaviors for Humanoid Robots",id:"recovery-behaviors-for-humanoid-robots",level:2},{value:"Humanoid-Specific Recovery Behaviors",id:"humanoid-specific-recovery-behaviors",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Navigation Performance Considerations",id:"navigation-performance-considerations",level:3},{value:"Best Practices for Humanoid Navigation",id:"best-practices-for-humanoid-navigation",level:2},{value:"Safety and Reliability",id:"safety-and-reliability",level:3},{value:"Performance Optimization",id:"performance-optimization-1",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Navigation Problems",id:"navigation-problems",level:3},{value:"Balance-Related Issues",id:"balance-related-issues",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function p(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-43-nav2-navigation-system",children:"Chapter 4.3: Nav2 Navigation System"})}),"\n",(0,o.jsx)(e.h2,{id:"goal",children:"Goal"}),"\n",(0,o.jsx)(e.p,{children:"Implement navigation capabilities for humanoid robots using Nav2."}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, students will configure and deploy navigation systems for humanoid robots."}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"Navigation is a critical capability for humanoid robots, enabling autonomous movement in complex environments. The Navigation2 (Nav2) stack represents the latest generation of ROS navigation tools, providing a flexible, behavior-based navigation system designed for modern robotics applications. For humanoid robots, navigation presents unique challenges due to their bipedal locomotion, complex kinematics, and specific environmental requirements. This chapter explores how to configure and implement Nav2 for humanoid robotics applications, addressing the specific requirements and constraints of bipedal navigation."}),"\n",(0,o.jsx)(e.h2,{id:"nav2-architecture-overview",children:"Nav2 Architecture Overview"}),"\n",(0,o.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 is built around a behavior-based architecture that provides flexibility and modularity:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Navigation Server"}),": The central orchestrator that manages navigation behaviors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Behavior Trees"}),": Define the logic and flow of navigation tasks"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Planners"}),": Global and local path planning algorithms"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Controllers"}),": Trajectory generation and tracking"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Behaviors"}),": Actions to take when navigation fails"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Lifecycle Manager"}),": Manages the state of navigation components"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"behavior-based-architecture",children:"Behavior-Based Architecture"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 uses behavior trees to define navigation logic, allowing for complex decision-making and recovery strategies:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example behavior tree for humanoid navigation --\x3e\n<root main_tree_to_execute="MainTree">\n  <BehaviorTree ID="MainTree">\n    <PipelineSequence name="NavigateWithReplanning">\n      <RateController hz="1">\n        <RecoveryNode number_of_retries="6" name="NavigateRecovery">\n          <PipelineSequence name="NavigateWithSmoothing">\n            <GoalUpdater input_port="goal" output_port="goal">\n              <Smoothing input_port="path" output_port="path">\n                <ComputePathToPose input_port="goal" output_port="path"/>\n              </Smoothing>\n            </GoalUpdater>\n            <RecoveryNode number_of_retries="2" name="FollowPathRecovery">\n              <FollowPath input_port="path"/>\n              <ReactiveFallback name="FollowPathWithRecovery">\n                <IsPathValid input_port="path"/>\n                <RecoveryNode number_of_retries="2" name="ClearingRotation">\n                  <ClearEntireCostmap name="ClearLocalCostmap" service_name="local_costmap/clear_entirely_local_costmap"/>\n                  <Spin spin_dist="1.57"/>\n                </RecoveryNode>\n              </ReactiveFallback>\n            </RecoveryNode>\n          </PipelineSequence>\n          <ReactiveFallback name="RecoveryFallback">\n            <GoalUpdated/>\n            <RecoveryNode number_of_retries="2" name="BackUpRecovery">\n              <ClearEntireCostmap name="ClearGlobalCostmap" service_name="global_costmap/clear_entirely_global_costmap"/>\n              <BackUp backup_dist="0.15" backup_speed="0.025"/>\n            </RecoveryNode>\n          </ReactiveFallback>\n        </RecoveryNode>\n      </RateController>\n    </PipelineSequence>\n  </BehaviorTree>\n</root>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"navigation-states",children:"Navigation States"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 operates through various states that define the current navigation behavior:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"IDLE"}),": Navigation server is ready but not executing"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"NAVIGATING"}),": Following a path to a goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"REPLANNING"}),": Adjusting the path based on new information"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CONTROLLING"}),": Tracking the current trajectory"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RECOVERING"}),": Executing recovery behaviors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"COMPLETING"}),": Approaching the final goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CANCELLING"}),": Stopping the current navigation task"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"nav2-configuration-for-humanoid-robots",children:"Nav2 Configuration for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"parameter-configuration",children:"Parameter Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 requires extensive parameter configuration, especially for humanoid robots with unique kinematics:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# nav2_params_humanoid.yaml\namcl:\n  ros__parameters:\n    use_sim_time: True\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_link"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    set_initial_pose: true\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.2\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n    scan_topic: scan\n\namcl_map_client:\n  ros__parameters:\n    use_sim_time: True\n\namcl_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Humanoid-specific behavior tree\n    default_nav_through_poses_bt_xml: /opt/ros/humble/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_and_recovery_humanoid.xml\n    default_nav_to_pose_bt_xml: /opt/ros/humble/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_and_recovery_humanoid.xml\n\nbt_navigator_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    # Humanoid-specific controller\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid-specific controller configuration\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_steps: 50\n      model_dt: 0.05\n      batch_size: 1000\n      vx_std: 0.2\n      vy_std: 0.1\n      wz_std: 0.3\n      vx_max: 0.5\n      vx_min: -0.2\n      vy_max: 0.3\n      wz_max: 0.5\n      sim_period: 0.05\n      penalty_dt: 0.1\n      # Humanoid-specific cost parameters\n      goal_angle_tolerance: 0.1\n      goal_position_tolerance: 0.2\n      xy_goal_tolerance: 0.3  # Larger for humanoid balance\n      trans_stopped_velocity: 0.25\n      theta_stopped_velocity: 0.25\n      stateful: True\n      critics: ["BaseObstacleCritic", "GoalCritic", "PathAlignCritic", "PreferForwardCritic"]\n\ncontroller_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: True\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05  # Higher resolution for humanoid precision\n      robot_radius: 0.3  # Humanoid radius\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 8\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n  local_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  local_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: True\n      robot_radius: 0.3  # Humanoid radius\n      resolution: 0.05  # Higher resolution for humanoid navigation\n      track_unknown_space: false\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n  global_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  global_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nmap_server:\n  ros__parameters:\n    use_sim_time: True\n    yaml_filename: "turtlebot3_world.yaml"\n\nmap_saver:\n  ros__parameters:\n    use_sim_time: True\n    save_map_timeout: 5.0\n    free_thresh_default: 0.25\n    occupied_thresh_default: 0.65\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: True\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5  # Humanoid tolerance\n      use_astar: false\n      allow_unknown: true\n\nplanner_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nsmoother_server:\n  ros__parameters:\n    use_sim_time: True\n    smoother_plugins: ["simple_smoother"]\n    simple_smoother:\n      plugin: "nav2_smoother::SimpleSmoother"\n      tolerance: 1.0e-10\n      max_its: 1000\n      do_refinement: True\n\nbehavior_server:\n  ros__parameters:\n    costmap_topic: local_costmap/costmap_raw\n    footprint_topic: local_costmap/published_footprint\n    cycle_frequency: 10.0\n    behavior_plugins: ["spin", "backup", "drive_on_heading", "wait"]\n    spin:\n      plugin: "nav2_behaviors::Spin"\n      spin_dist: 1.57\n      linear_steps: 10\n      max_angular_accel: 3.2\n      max_angular_vel: 1.0\n    backup:\n      plugin: "nav2_behaviors::BackUp"\n      backup_dist: 0.15\n      backup_speed: 0.025\n      sim_time: 2.0\n      linear_accel: 1.0\n      threshold_dist: 0.01\n    drive_on_heading:\n      plugin: "nav2_behaviors::DriveOnHeading"\n      sim_time: 5.0\n      linear_vel: 0.2\n      angular_vel: 1.0\n      tolerance: 0.5\n      use_small_path: true\n      target_x: 0.0\n      target_y: 0.0\n    wait:\n      plugin: "nav2_behaviors::Wait"\n      wait_duration: 1.0\n\nwaypoint_follower:\n  ros__parameters:\n    loop_rate: 20\n    stop_on_failure: false\n    waypoint_task_executor_plugin: "wait_at_waypoint"\n    wait_at_waypoint:\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\n      enabled: true\n      waypoint_pause_duration: 200\n'})}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-navigation-parameters",children:"Humanoid-Specific Navigation Parameters"}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robots, special parameters are needed to account for their unique characteristics:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# humanoid_nav2_params.yaml\ncontroller_server:\n  ros__parameters:\n    # Humanoid-specific velocity constraints\n    max_linear_velocity: 0.3      # Slower for balance\n    max_angular_velocity: 0.4     # Controlled turning\n    min_linear_velocity: 0.05     # Minimum for stability\n    min_angular_velocity: 0.05\n\n    # Humanoid-specific tolerances\n    xy_goal_tolerance: 0.4        # Larger tolerance for balance\n    yaw_goal_tolerance: 0.2       # Angular tolerance\n\n    # Balance-aware navigation\n    max_vel_x: 0.3\n    min_vel_x: 0.05\n    max_vel_theta: 0.4\n    min_vel_theta: 0.05\n\n    # Humanoid-specific acceleration limits\n    acc_lim_x: 0.5\n    acc_lim_theta: 0.5\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      # Humanoid-specific footprint\n      robot_radius: 0.35          # Larger for humanoid safety\n      footprint_padding: 0.1      # Extra padding for balance\n\n      # Higher resolution for precise navigation\n      resolution: 0.025           # Finer resolution\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      # Humanoid-specific parameters\n      robot_radius: 0.35\n      resolution: 0.05\n      # Include passable stairs and slopes\n      track_unknown_space: true\n"})}),"\n",(0,o.jsx)(e.h2,{id:"path-planning-for-humanoid-robots",children:"Path Planning for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"global-path-planning",children:"Global Path Planning"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots require special considerations for global path planning due to their bipedal nature:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped\nfrom builtin_interfaces.msg import Time\nimport numpy as np\n\nclass HumanoidPathPlanner(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_path_planner\')\n\n        # Publisher for planned path\n        self.path_pub = self.create_publisher(Path, \'humanoid_plan\', 10)\n\n        # Subscription for goal poses\n        self.goal_sub = self.create_subscription(\n            PoseStamped,\n            \'goal_pose\',\n            self.goal_callback,\n            10\n        )\n\n        # Costmap for humanoid-specific navigation\n        self.humanoid_costmap = HumanoidCostmap()\n\n        # Path planning algorithm\n        self.planner = HumanoidAStarPlanner()\n\n    def goal_callback(self, goal_msg):\n        """Handle navigation goal for humanoid robot"""\n        # Get current robot pose\n        current_pose = self.get_current_pose()\n\n        # Plan path considering humanoid constraints\n        path = self.plan_humanoid_path(current_pose, goal_msg.pose)\n\n        # Publish the planned path\n        self.publish_path(path)\n\n    def plan_humanoid_path(self, start_pose, goal_pose):\n        """Plan path considering humanoid-specific constraints"""\n        # Consider step height limitations\n        # Consider slope limitations\n        # Consider balance constraints\n\n        # Use costmap that accounts for humanoid capabilities\n        humanoid_costmap = self.humanoid_costmap.get_costmap()\n\n        # Plan path using humanoid-aware algorithm\n        path = self.planner.plan(\n            start_pose,\n            goal_pose,\n            humanoid_costmap,\n            step_height_limit=0.15,  # Humanoid step height\n            slope_limit=20.0         # Maximum slope in degrees\n        )\n\n        return path\n\n    def get_current_pose(self):\n        """Get current robot pose from localization"""\n        # This would typically come from AMCL or other localization\n        pass\n\n    def publish_path(self, path):\n        """Publish planned path with proper header"""\n        path_msg = Path()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = \'map\'\n\n        for pose in path:\n            pose_stamped = PoseStamped()\n            pose_stamped.header.stamp = Time()\n            pose_stamped.header.frame_id = \'map\'\n            pose_stamped.pose = pose\n            path_msg.poses.append(pose_stamped)\n\n        self.path_pub.publish(path_msg)\n\nclass HumanoidCostmap:\n    def __init__(self):\n        # Initialize costmap with humanoid-specific constraints\n        self.step_height_threshold = 0.15  # Maximum step height\n        self.slope_threshold = 20.0        # Maximum slope in degrees\n        self.min_passage_width = 0.6       # Minimum passage width for humanoid\n\n    def get_costmap(self):\n        """Generate costmap considering humanoid constraints"""\n        # This would integrate with Nav2 costmap but add humanoid-specific costs\n        # - Areas with steps higher than threshold\n        # - Areas with slopes steeper than threshold\n        # - Narrow passages\n        # - Areas requiring complex balance\n        pass\n\nclass HumanoidAStarPlanner:\n    def __init__(self):\n        # Initialize A* planner with humanoid constraints\n        pass\n\n    def plan(self, start, goal, costmap, step_height_limit, slope_limit):\n        """Plan path using A* with humanoid constraints"""\n        # Implement A* search that considers humanoid-specific costs\n        # - Step height costs\n        # - Slope costs\n        # - Balance requirement costs\n        # - Foot placement costs\n        pass\n'})}),"\n",(0,o.jsx)(e.h3,{id:"local-path-planning-and-obstacle-avoidance",children:"Local Path Planning and Obstacle Avoidance"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nfrom visualization_msgs.msg import MarkerArray\n\nclass HumanoidLocalPlanner:\n    def __init__(self):\n        self.obstacle_threshold = 0.5  # Minimum distance to obstacles\n        self.humanoid_width = 0.6      # Width of humanoid robot\n        self.step_size = 0.1           # Size of each step for planning\n\n        # For real-time obstacle avoidance\n        self.laser_data = None\n        self.current_velocity = Twist()\n\n    def update_laser_data(self, laser_msg):\n        """Update laser scan data for obstacle detection"""\n        self.laser_data = laser_msg\n\n    def compute_velocity_commands(self, global_path, current_pose, current_vel):\n        """Compute velocity commands considering obstacles and path following"""\n        if self.laser_data is None:\n            return Twist()  # No sensor data, stop\n\n        # Check for immediate obstacles\n        if self.detect_immediate_obstacles():\n            # Emergency stop or slow down\n            cmd_vel = self.emergency_stop()\n        else:\n            # Follow path with obstacle avoidance\n            cmd_vel = self.follow_path_with_obstacle_avoidance(\n                global_path, current_pose, current_vel\n            )\n\n        return cmd_vel\n\n    def detect_immediate_obstacles(self):\n        """Detect obstacles in immediate vicinity"""\n        if self.laser_data is None:\n            return False\n\n        # Check if any obstacles are within safety threshold\n        min_distance = min(self.laser_data.ranges)\n        return min_distance < self.obstacle_threshold\n\n    def emergency_stop(self):\n        """Generate emergency stop command"""\n        cmd_vel = Twist()\n        cmd_vel.linear.x = 0.0\n        cmd_vel.angular.z = 0.0\n        return cmd_vel\n\n    def follow_path_with_obstacle_avoidance(self, global_path, current_pose, current_vel):\n        """Follow global path while avoiding obstacles"""\n        # Get next waypoint from global path\n        next_waypoint = self.get_next_waypoint(global_path, current_pose)\n\n        # Calculate desired direction to waypoint\n        desired_direction = self.calculate_desired_direction(\n            current_pose, next_waypoint\n        )\n\n        # Check for obstacles in desired direction\n        obstacle_direction = self.check_obstacle_direction(desired_direction)\n\n        # Generate velocity command\n        cmd_vel = Twist()\n        if obstacle_direction is None:\n            # No obstacles in desired direction, move toward waypoint\n            cmd_vel.linear.x = self.calculate_linear_velocity(\n                current_pose, next_waypoint\n            )\n            cmd_vel.angular.z = self.calculate_angular_velocity(\n                current_pose, next_waypoint\n            )\n        else:\n            # Obstacle detected, adjust for avoidance\n            cmd_vel = self.avoid_obstacle(obstacle_direction, desired_direction)\n\n        # Apply humanoid-specific velocity limits\n        cmd_vel = self.apply_humanoid_constraints(cmd_vel)\n\n        return cmd_vel\n\n    def check_obstacle_direction(self, desired_direction):\n        """Check if obstacles exist in desired movement direction"""\n        if self.laser_data is None:\n            return None\n\n        # Convert desired direction to laser frame and check corresponding angles\n        # Return direction of obstacle if detected\n        pass\n\n    def avoid_obstacle(self, obstacle_dir, desired_dir):\n        """Generate command to avoid obstacle"""\n        cmd_vel = Twist()\n\n        # Simple obstacle avoidance: turn away from obstacle\n        # More sophisticated methods would use potential fields or DWA\n        cmd_vel.angular.z = 0.3 if obstacle_dir > 0 else -0.3\n        cmd_vel.linear.x = 0.1  # Move slowly while turning\n\n        return cmd_vel\n\n    def apply_humanoid_constraints(self, cmd_vel):\n        """Apply humanoid-specific velocity and acceleration constraints"""\n        # Apply maximum velocity limits\n        cmd_vel.linear.x = max(min(cmd_vel.linear.x, 0.3), -0.1)  # Forward: 0.3, backward: 0.1\n        cmd_vel.angular.z = max(min(cmd_vel.angular.z, 0.4), -0.4)  # Angular: \xb10.4\n\n        # Apply acceleration limits\n        # This would consider current velocity and desired acceleration\n        return cmd_vel\n'})}),"\n",(0,o.jsx)(e.h2,{id:"navigation-controllers-for-humanoid-robots",children:"Navigation Controllers for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-aware-trajectory-controller",children:"Humanoid-Aware Trajectory Controller"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Path\nfrom tf2_ros import TransformListener, Buffer\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass HumanoidTrajectoryController:\n    def __init__(self):\n        # PID controller parameters\n        self.kp_linear = 1.0\n        self.ki_linear = 0.1\n        self.kd_linear = 0.05\n\n        self.kp_angular = 2.0\n        self.ki_angular = 0.1\n        self.kd_angular = 0.1\n\n        # Error integrals for PID\n        self.linear_error_integral = 0.0\n        self.angular_error_integral = 0.0\n\n        self.previous_linear_error = 0.0\n        self.previous_angular_error = 0.0\n\n        # Humanoid-specific parameters\n        self.max_linear_vel = 0.3\n        self.max_angular_vel = 0.4\n        self.min_linear_vel = 0.02  # Minimum for stability\n        self.min_angular_vel = 0.05\n\n        # Lookahead distance for path following\n        self.lookahead_dist = 0.5\n\n        # Balance constraints\n        self.balance_threshold = 0.1  # Maximum deviation from nominal pose\n\n    def follow_path(self, path, current_pose, current_velocity):\n        """Follow the given path with humanoid-aware control"""\n        if len(path.poses) == 0:\n            return Twist()  # No path to follow\n\n        # Find closest point on path\n        closest_idx = self.find_closest_point(path, current_pose)\n\n        # Get lookahead point\n        lookahead_point = self.get_lookahead_point(path, current_pose, closest_idx)\n\n        if lookahead_point is None:\n            return Twist()  # Can\'t find valid lookahead point\n\n        # Calculate control commands\n        cmd_vel = self.calculate_control(current_pose, lookahead_point, current_velocity)\n\n        # Apply humanoid constraints\n        cmd_vel = self.apply_humanoid_constraints(cmd_vel)\n\n        # Check balance requirements\n        if not self.check_balance_feasibility(cmd_vel):\n            # Reduce speed to maintain balance\n            cmd_vel.linear.x *= 0.5\n            cmd_vel.angular.z *= 0.5\n\n        return cmd_vel\n\n    def find_closest_point(self, path, current_pose):\n        """Find the closest point on path to current pose"""\n        min_dist = float(\'inf\')\n        closest_idx = 0\n\n        for i, pose in enumerate(path.poses):\n            dist = self.calculate_distance(current_pose.pose, pose.pose)\n            if dist < min_dist:\n                min_dist = dist\n                closest_idx = i\n\n        return closest_idx\n\n    def get_lookahead_point(self, path, current_pose, start_idx):\n        """Get point ahead on path for path following"""\n        current_pos = np.array([\n            current_pose.pose.position.x,\n            current_pose.pose.position.y\n        ])\n\n        for i in range(start_idx, len(path.poses)):\n            path_pos = np.array([\n                path.poses[i].pose.position.x,\n                path.poses[i].pose.position.y\n            ])\n\n            dist = np.linalg.norm(path_pos - current_pos)\n\n            if dist >= self.lookahead_dist:\n                return path.poses[i].pose\n\n        # If no point is far enough, return the last point\n        if len(path.poses) > 0:\n            return path.poses[-1].pose\n\n        return None\n\n    def calculate_control(self, current_pose, target_pose, current_velocity):\n        """Calculate linear and angular velocities using PID control"""\n        # Calculate errors\n        linear_error, angular_error = self.calculate_errors(\n            current_pose, target_pose\n        )\n\n        # Update error integrals\n        self.linear_error_integral += linear_error\n        self.angular_error_integral += angular_error\n\n        # Calculate derivatives\n        linear_error_derivative = linear_error - self.previous_linear_error\n        angular_error_derivative = angular_error - self.previous_angular_error\n\n        # Calculate control outputs\n        linear_vel = (\n            self.kp_linear * linear_error +\n            self.ki_linear * self.linear_error_integral +\n            self.kd_linear * linear_error_derivative\n        )\n\n        angular_vel = (\n            self.kp_angular * angular_error +\n            self.ki_angular * self.angular_error_integral +\n            self.kd_angular * angular_error_derivative\n        )\n\n        # Create command\n        cmd_vel = Twist()\n        cmd_vel.linear.x = linear_vel\n        cmd_vel.angular.z = angular_vel\n\n        # Update previous errors\n        self.previous_linear_error = linear_error\n        self.previous_angular_error = angular_error\n\n        return cmd_vel\n\n    def calculate_errors(self, current_pose, target_pose):\n        """Calculate linear and angular errors"""\n        # Current position\n        curr_x = current_pose.pose.position.x\n        curr_y = current_pose.pose.position.y\n\n        # Current orientation\n        curr_quat = [\n            current_pose.pose.orientation.x,\n            current_pose.pose.orientation.y,\n            current_pose.pose.orientation.z,\n            current_pose.pose.orientation.w\n        ]\n        curr_yaw = self.quaternion_to_yaw(curr_quat)\n\n        # Target position\n        target_x = target_pose.position.x\n        target_y = target_pose.position.y\n\n        # Calculate distance error\n        dx = target_x - curr_x\n        dy = target_y - curr_y\n        linear_error = np.sqrt(dx*dx + dy*dy)\n\n        # Calculate heading error\n        target_angle = np.arctan2(dy, dx)\n        angular_error = self.normalize_angle(target_angle - curr_yaw)\n\n        return linear_error, angular_error\n\n    def apply_humanoid_constraints(self, cmd_vel):\n        """Apply humanoid-specific constraints to velocity commands"""\n        # Limit linear velocity\n        cmd_vel.linear.x = max(\n            min(cmd_vel.linear.x, self.max_linear_vel),\n            -self.max_linear_vel * 0.5  # Allow slower backward movement\n        )\n\n        # Ensure minimum velocity for stability\n        if abs(cmd_vel.linear.x) < self.min_linear_vel and cmd_vel.linear.x != 0:\n            cmd_vel.linear.x = (self.min_linear_vel if cmd_vel.linear.x > 0\n                                else -self.min_linear_vel)\n\n        # Limit angular velocity\n        cmd_vel.angular.z = max(\n            min(cmd_vel.angular.z, self.max_angular_vel),\n            -self.max_angular_vel\n        )\n\n        # Ensure minimum angular velocity\n        if abs(cmd_vel.angular.z) < self.min_angular_vel and cmd_vel.angular.z != 0:\n            cmd_vel.angular.z = (self.min_angular_vel if cmd_vel.angular.z > 0\n                                 else -self.min_angular_vel)\n\n        return cmd_vel\n\n    def check_balance_feasibility(self, cmd_vel):\n        """Check if the velocity command is balance-feasible for humanoid"""\n        # This is a simplified check - in reality, would involve\n        # complex balance stability analysis\n        linear_speed = abs(cmd_vel.linear.x)\n        angular_speed = abs(cmd_vel.angular.z)\n\n        # Simple heuristic: higher speeds require more balance control\n        combined_speed = linear_speed + angular_speed * 0.5\n        return combined_speed <= 0.5  # Threshold for balance feasibility\n\n    def quaternion_to_yaw(self, quat):\n        """Convert quaternion to yaw angle"""\n        # Convert quaternion to yaw (z-axis rotation)\n        sinr_cosp = 2 * (quat[3] * quat[2] + quat[0] * quat[1])\n        cosr_cosp = 1 - 2 * (quat[1] * quat[1] + quat[2] * quat[2])\n        return np.arctan2(sinr_cosp, cosr_cosp)\n\n    def normalize_angle(self, angle):\n        """Normalize angle to [-pi, pi] range"""\n        while angle > np.pi:\n            angle -= 2 * np.pi\n        while angle < -np.pi:\n            angle += 2 * np.pi\n        return angle\n'})}),"\n",(0,o.jsx)(e.h3,{id:"footstep-planning-for-humanoid-navigation",children:"Footstep Planning for Humanoid Navigation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class HumanoidFootstepPlanner:\n    def __init__(self):\n        self.step_length = 0.3    # Distance between footsteps\n        self.step_width = 0.2     # Lateral distance between feet\n        self.max_step_height = 0.15  # Maximum step height\n\n    def plan_footsteps(self, path, current_pose):\n        """Plan footstep locations along the navigation path"""\n        footsteps = []\n\n        # Start with current pose\n        current_pos = [current_pose.pose.position.x,\n                      current_pose.pose.position.y,\n                      current_pose.pose.position.z]\n\n        # Iterate through path and generate footsteps\n        for i in range(1, len(path.poses)):\n            target_pos = [path.poses[i].pose.position.x,\n                         path.poses[i].pose.position.y,\n                         path.poses[i].pose.position.z]\n\n            # Generate footsteps between current and target positions\n            steps = self.generate_steps(current_pos, target_pos)\n            footsteps.extend(steps)\n\n            current_pos = target_pos\n\n        return footsteps\n\n    def generate_steps(self, start_pos, end_pos):\n        """Generate intermediate footsteps between two positions"""\n        steps = []\n\n        # Calculate direction vector\n        direction = np.array(end_pos) - np.array(start_pos)\n        distance = np.linalg.norm(direction[:2])  # 2D distance\n\n        if distance < self.step_length:\n            # Direct step to target\n            steps.append(end_pos)\n        else:\n            # Generate multiple steps\n            num_steps = int(distance / self.step_length)\n            step_vector = direction / num_steps\n\n            for i in range(1, num_steps + 1):\n                step_pos = start_pos + step_vector * i\n                steps.append(step_pos.tolist())\n\n        return steps\n'})}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-isaac-sim-navigation",children:"Integration with Isaac Sim Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"isaac-sim-navigation-setup",children:"Isaac Sim Navigation Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.navigation.scripts import nav_core\n\nclass IsaacSimNavigationManager:\n    def __init__(self):\n        self.world = None\n        self.navigation_map = None\n        self.nav_goal_publisher = None\n        self.nav_path_subscriber = None\n\n    def setup_navigation_environment(self):\n        """Setup Isaac Sim environment with navigation capabilities"""\n        # Initialize Isaac Sim world\n        self.world = World(stage_units_in_meters=1.0)\n\n        # Add navigation-relevant assets\n        assets_root_path = get_assets_root_path()\n\n        # Add ground plane\n        add_reference_to_stage(\n            assets_root_path + "/Isaac/Environments/Grid/default_environment.usd",\n            "/World/defaultGround"\n        )\n\n        # Add navigation-relevant objects\n        self.add_navigation_features()\n\n        # Setup navigation system\n        self.setup_nav_core()\n\n    def add_navigation_features(self):\n        """Add navigation-relevant features to the environment"""\n        # Add landmarks for localization\n        self.add_landmarks()\n\n        # Add navigation goals\n        self.add_navigation_goals()\n\n        # Add obstacles\n        self.add_dynamic_obstacles()\n\n    def add_landmarks(self):\n        """Add visual landmarks for robot localization"""\n        # Add distinctive objects that can be used for localization\n        landmark_configs = [\n            {"type": "cylinder", "position": [5, 0, 1], "name": "landmark_1"},\n            {"type": "box", "position": [-5, 3, 1], "name": "landmark_2"},\n            {"type": "sphere", "position": [0, -5, 1], "name": "landmark_3"}\n        ]\n\n        for config in landmark_configs:\n            add_reference_to_stage(\n                self.get_asset_path(config["type"]),\n                f"/World/Landmarks/{config[\'name\']}"\n            )\n\n    def setup_nav_core(self):\n        """Setup navigation core system in Isaac Sim"""\n        # This would typically involve setting up the navigation mesh\n        # and other Isaac Sim navigation components\n        pass\n\n    def setup_ros_bridge_for_navigation(self):\n        """Setup ROS bridge for navigation communication"""\n        # Setup publishers and subscribers for navigation\n        # This connects Isaac Sim navigation to ROS Nav2\n        pass\n'})}),"\n",(0,o.jsx)(e.h3,{id:"navigation-in-simulation",children:"Navigation in Simulation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class IsaacSimNavigationController:\n    def __init__(self, robot, world):\n        self.robot = robot\n        self.world = world\n        self.nav_goal_subscriber = None\n        self.nav_path_publisher = None\n        self.localization_system = None\n\n    def execute_navigation_task(self, goal_pose):\n        """Execute navigation task in Isaac Sim"""\n        # Plan path to goal\n        path = self.plan_path_to_goal(goal_pose)\n\n        if path is None:\n            self.get_logger().error("Could not plan path to goal")\n            return False\n\n        # Execute navigation along path\n        success = self.follow_path(path)\n\n        return success\n\n    def plan_path_to_goal(self, goal_pose):\n        """Plan path in simulation environment"""\n        # This would interface with Isaac Sim\'s path planning\n        # or use a connected Nav2 system\n        pass\n\n    def follow_path(self, path):\n        """Follow path in simulation with humanoid-aware control"""\n        controller = HumanoidTrajectoryController()\n\n        for waypoint in path:\n            # Get current robot state\n            current_pose = self.robot.get_world_pose()\n            current_velocity = self.robot.get_velocities()\n\n            # Calculate control command\n            cmd_vel = controller.follow_path([waypoint], current_pose, current_velocity)\n\n            # Apply command to robot\n            self.apply_velocity_command(cmd_vel)\n\n            # Step simulation\n            self.world.step(render=True)\n\n            # Check if reached waypoint\n            if self.reached_waypoint(current_pose, waypoint):\n                continue  # Move to next waypoint\n\n        return True  # Successfully followed path\n\n    def apply_velocity_command(self, cmd_vel):\n        """Apply velocity command to humanoid robot in simulation"""\n        # Convert Twist command to joint commands for humanoid\n        # This involves complex inverse kinematics and balance control\n        pass\n\n    def reached_waypoint(self, current_pose, waypoint, tolerance=0.2):\n        """Check if robot reached the waypoint"""\n        current_pos = np.array([\n            current_pose[0][0],  # x\n            current_pose[0][1],  # y\n        ])\n\n        waypoint_pos = np.array([\n            waypoint.pose.position.x,\n            waypoint.pose.position.y\n        ])\n\n        distance = np.linalg.norm(current_pos - waypoint_pos)\n        return distance <= tolerance\n'})}),"\n",(0,o.jsx)(e.h2,{id:"recovery-behaviors-for-humanoid-robots",children:"Recovery Behaviors for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-recovery-behaviors",children:"Humanoid-Specific Recovery Behaviors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class HumanoidRecoveryBehaviors:\n    def __init__(self, robot):\n        self.robot = robot\n        self.balance_controller = None\n        self.recovery_timeout = 30.0  # seconds\n\n    def clear_costmap_recovery(self, costmap_type="local"):\n        """Clear costmap to recover from navigation issues"""\n        # In simulation, this might involve resetting costmap data\n        # In real robots, this would call the costmap clear service\n        pass\n\n    def spin_recovery(self, angle=1.57):\n        """Spin in place to clear local minima"""\n        # Implement controlled spinning motion for humanoid\n        # This needs to maintain balance while turning\n        start_yaw = self.get_robot_yaw()\n        target_yaw = start_yaw + angle\n\n        cmd_vel = Twist()\n        cmd_vel.angular.z = 0.2  # Slow rotation for balance\n\n        start_time = self.get_clock().now()\n\n        while self.get_robot_yaw() < target_yaw:\n            current_time = self.get_clock().now()\n            if (current_time - start_time).nanoseconds / 1e9 > self.recovery_timeout:\n                break  # Timeout\n\n            # Apply command and step simulation\n            self.apply_command(cmd_vel)\n            self.world.step(render=True)\n\n    def backup_recovery(self, distance=0.2, speed=0.05):\n        """Backup to escape difficult situations"""\n        # Get initial position\n        initial_pos = self.robot.get_world_pose()[0]\n\n        # Move backward slowly to maintain balance\n        cmd_vel = Twist()\n        cmd_vel.linear.x = -speed\n\n        while True:\n            # Check if moved desired distance\n            current_pos = self.robot.get_world_pose()[0]\n            moved_distance = np.linalg.norm(np.array(current_pos) - np.array(initial_pos))\n\n            if moved_distance >= distance:\n                break\n\n            # Apply command and step simulation\n            self.apply_command(cmd_vel)\n            self.world.step(render=True)\n\n    def balance_recovery(self):\n        """Recover balance if humanoid is unstable"""\n        # Implement balance recovery sequence\n        # This might involve adjusting stance, COM position, etc.\n        pass\n\n    def wait_recovery(self, duration=2.0):\n        """Wait for a specified duration as recovery"""\n        start_time = self.get_clock().now()\n\n        while True:\n            current_time = self.get_clock().now()\n            elapsed = (current_time - start_time).nanoseconds / 1e9\n\n            if elapsed >= duration:\n                break\n\n            # Stop robot during wait\n            self.apply_command(Twist())\n            self.world.step(render=True)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"navigation-performance-considerations",children:"Navigation Performance Considerations"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class OptimizedHumanoidNavigation:\n    def __init__(self):\n        self.path_cache = {}  # Cache frequently used paths\n        self.localization_accuracy = 0.1  # meters\n        self.planning_frequency = 1.0     # Hz\n        self.control_frequency = 20.0     # Hz\n\n    def optimize_path_planning(self, start, goal):\n        """Optimize path planning for performance"""\n        # Check if path is already cached\n        cache_key = (start, goal)\n        if cache_key in self.path_cache:\n            return self.path_cache[cache_key]\n\n        # Plan path\n        path = self.plan_path(start, goal)\n\n        # Cache the result\n        self.path_cache[cache_key] = path\n\n        return path\n\n    def adaptive_planning_frequency(self, environment_complexity):\n        """Adjust planning frequency based on environment"""\n        if environment_complexity > 0.7:  # High complexity\n            return 2.0  # Plan more frequently\n        elif environment_complexity < 0.3:  # Low complexity\n            return 0.5  # Plan less frequently\n        else:\n            return 1.0  # Default frequency\n\n    def optimize_controller(self, robot_state):\n        """Optimize controller parameters based on robot state"""\n        # Adjust controller gains based on terrain, speed, etc.\n        if robot_state[\'on_slopes\']:\n            # Reduce gains for stability on slopes\n            self.controller.kp_linear *= 0.8\n            self.controller.kp_angular *= 0.8\n        else:\n            # Use normal gains\n            self.controller.kp_linear = self.default_kp_linear\n            self.controller.kp_angular = self.default_kp_angular\n'})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices-for-humanoid-navigation",children:"Best Practices for Humanoid Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"safety-and-reliability",children:"Safety and Reliability"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement multiple levels of safety checks"}),"\n",(0,o.jsx)(e.li,{children:"Use conservative velocity limits for humanoid stability"}),"\n",(0,o.jsx)(e.li,{children:"Include proper localization validation"}),"\n",(0,o.jsx)(e.li,{children:"Implement appropriate recovery behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Test thoroughly in simulation before real-world deployment"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization-1",children:"Performance Optimization"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Use appropriate planning frequencies"}),"\n",(0,o.jsx)(e.li,{children:"Optimize costmap resolution for humanoid requirements"}),"\n",(0,o.jsx)(e.li,{children:"Implement efficient path smoothing"}),"\n",(0,o.jsx)(e.li,{children:"Use caching for frequently computed paths"}),"\n",(0,o.jsx)(e.li,{children:"Monitor computational performance"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Test on various terrain types"}),"\n",(0,o.jsx)(e.li,{children:"Validate localization accuracy"}),"\n",(0,o.jsx)(e.li,{children:"Test recovery behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Verify balance constraints"}),"\n",(0,o.jsx)(e.li,{children:"Test in complex, dynamic environments"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"navigation-problems",children:"Navigation Problems"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def diagnose_navigation_issues():\n    """Diagnose common navigation issues for humanoid robots"""\n    issues = []\n\n    # Check localization quality\n    localization_accuracy = check_localization_accuracy()\n    if localization_accuracy > 0.5:  # More than 50cm error\n        issues.append("Poor localization accuracy - consider improving landmark detection")\n\n    # Check path planning\n    path_success_rate = check_path_planning_success()\n    if path_success_rate < 0.8:  # Less than 80% success\n        issues.append("Frequent path planning failures - check costmap configuration")\n\n    # Check controller performance\n    tracking_error = check_path_tracking_error()\n    if tracking_error > 0.3:  # More than 30cm tracking error\n        issues.append("Poor path tracking - adjust controller parameters")\n\n    # Check recovery behavior frequency\n    recovery_frequency = check_recovery_frequency()\n    if recovery_frequency > 0.1:  # More than 10% of time in recovery\n        issues.append("Too frequent recovery behaviors - investigate root cause")\n\n    return issues\n'})}),"\n",(0,o.jsx)(e.h3,{id:"balance-related-issues",children:"Balance-Related Issues"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce navigation speed in complex environments"}),"\n",(0,o.jsx)(e.li,{children:"Increase safety margins around obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Use more conservative turning rates"}),"\n",(0,o.jsx)(e.li,{children:"Implement balance-aware path planning"}),"\n",(0,o.jsx)(e.li,{children:"Adjust controller parameters for stability"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 provides a comprehensive navigation system that can be adapted for humanoid robotics applications. The key to successful humanoid navigation lies in properly configuring the system to account for the unique characteristics of bipedal robots, including balance constraints, step limitations, and stability requirements. Proper integration with simulation environments like Isaac Sim enables thorough testing and validation before deployment on real hardware."}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Configure Nav2 for a humanoid robot with appropriate parameters"}),"\n",(0,o.jsx)(e.li,{children:"Implement a humanoid-aware path planner that considers step height limitations"}),"\n",(0,o.jsx)(e.li,{children:"Create custom recovery behaviors for humanoid-specific navigation challenges"}),"\n",(0,o.jsx)(e.li,{children:"Test navigation performance in Isaac Sim with various terrain types"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,o.jsx)(e.p,{children:'[1] S. Koenig and R. Simmons, "XNap: High-Quality Path Planning for Mobile Robots," Journal of Field Robotics, vol. 15, no. 8, pp. 447-462, 1998.'}),"\n",(0,o.jsx)(e.p,{children:'[2] M. Quigley et al., "Pareto Optimal Multi-Robot Path Planning," IEEE ICRA, 2009.'}),"\n",(0,o.jsxs)(e.p,{children:['[3] Nav2 Documentation, "Navigation2 User Guide," ',(0,o.jsx)(e.a,{href:"https://navigation.ros.org/",children:"https://navigation.ros.org/"})]})]})}function _(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}}}]);