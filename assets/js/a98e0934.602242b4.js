"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[156],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(96540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},61888:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-ros2-fundamentals/advanced-ros2-patterns","title":"Chapter 2.4 - Advanced ROS 2 Patterns","description":"Parameter Management, Launch Files, and Testing","source":"@site/docs/module-2-ros2-fundamentals/advanced-ros2-patterns.mdx","sourceDirName":"module-2-ros2-fundamentals","slug":"/module-2-ros2-fundamentals/advanced-ros2-patterns","permalink":"/humanoid-robotics-book/docs/module-2-ros2-fundamentals/advanced-ros2-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/ibrahimgem/humanoid-robotics-book/edit/main/docs/module-2-ros2-fundamentals/advanced-ros2-patterns.mdx","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"Chapter 2.4 - Advanced ROS 2 Patterns","description":"Parameter Management, Launch Files, and Testing"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2.3 - rclpy and Python Robotics","permalink":"/humanoid-robotics-book/docs/module-2-ros2-fundamentals/rclpy-python-robotics"},"next":{"title":"Module 3 - Simulation Environments","permalink":"/humanoid-robotics-book/docs/category/module-3---simulation-environments"}}');var a=t(74848),o=t(28453);const r={sidebar_position:9,title:"Chapter 2.4 - Advanced ROS 2 Patterns",description:"Parameter Management, Launch Files, and Testing"},i="Chapter 2.4: Advanced ROS 2 Patterns",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Advanced Parameter Management",id:"advanced-parameter-management",level:2},{value:"Parameter Descriptors",id:"parameter-descriptors",level:3},{value:"Parameter Validation",id:"parameter-validation",level:3},{value:"Dynamic Parameter Reconfiguration",id:"dynamic-parameter-reconfiguration",level:3},{value:"Advanced Launch Systems",id:"advanced-launch-systems",level:2},{value:"Complex Launch Files",id:"complex-launch-files",level:3},{value:"Conditional Launch",id:"conditional-launch",level:3},{value:"Launch Testing",id:"launch-testing",level:3},{value:"Testing in ROS 2",id:"testing-in-ros-2",level:2},{value:"Unit Testing with pytest",id:"unit-testing-with-pytest",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Mock Testing",id:"mock-testing",level:3},{value:"Design Patterns for Robotic Systems",id:"design-patterns-for-robotic-systems",level:2},{value:"State Machine Pattern",id:"state-machine-pattern",level:3},{value:"Observer Pattern",id:"observer-pattern",level:3},{value:"Command Pattern",id:"command-pattern",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient Message Handling",id:"efficient-message-handling",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Testing Strategies for Humanoid Robotics",id:"testing-strategies-for-humanoid-robotics",level:2},{value:"Hardware-in-the-Loop Testing",id:"hardware-in-the-loop-testing",level:3},{value:"Simulation Testing",id:"simulation-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:3},{value:"Performance Best Practices",id:"performance-best-practices",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-24-advanced-ros-2-patterns",children:"Chapter 2.4: Advanced ROS 2 Patterns"})}),"\n",(0,a.jsx)(n.h2,{id:"goal",children:"Goal"}),"\n",(0,a.jsx)(n.p,{children:"Master advanced ROS 2 concepts including parameter management, launch systems, and testing."}),"\n",(0,a.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,a.jsx)(n.p,{children:"After completing this chapter, students will implement complex robotic systems with proper configuration and testing."}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"As robotic systems become more complex, especially in humanoid robotics applications, it becomes essential to manage configuration, deployment, and testing systematically. This chapter covers advanced ROS 2 patterns that enable the development of robust, maintainable, and scalable robotic systems. These patterns are particularly important for humanoid robots, which typically involve multiple subsystems that need to work together seamlessly."}),"\n",(0,a.jsx)(n.h2,{id:"advanced-parameter-management",children:"Advanced Parameter Management"}),"\n",(0,a.jsx)(n.h3,{id:"parameter-descriptors",children:"Parameter Descriptors"}),"\n",(0,a.jsx)(n.p,{children:"Parameter descriptors allow you to specify constraints and callbacks for parameters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rclpy.parameter import Parameter\nfrom rclpy.node import Node\n\nclass ParameterNode(Node):\n    def __init__(self):\n        super().__init__('parameter_node')\n\n        # Declare parameters with descriptors\n        self.declare_parameter(\n            'max_velocity',\n            1.0,\n            ParameterDescriptor(\n                description='Maximum joint velocity in rad/s',\n                type=ParameterType.PARAMETER_DOUBLE,\n                floating_point_range=[ParameterRange(from_value=0.0, to_value=10.0, step=0.1)]\n            )\n        )\n\n        self.declare_parameter(\n            'joint_names',\n            ['joint1', 'joint2', 'joint3'],\n            ParameterDescriptor(\n                description='List of joint names for the robot',\n                type=ParameterType.PARAMETER_STRING_ARRAY\n            )\n        )\n"})}),"\n",(0,a.jsx)(n.h3,{id:"parameter-validation",children:"Parameter Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rclpy.exceptions import ParameterNotDeclaredException\nfrom rclpy.parameter import Parameter\nfrom rclpy.node import Node\n\nclass ValidatedParameterNode(Node):\n    def __init__(self):\n        super().__init__('validated_parameter_node')\n\n        # Declare parameters\n        self.declare_parameter('control_frequency', 100.0)\n        self.declare_parameter('max_torque', 10.0)\n\n        # Add parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, parameters):\n        result = SetParametersResult()\n        result.successful = True\n\n        for param in parameters:\n            if param.name == 'control_frequency':\n                if param.value <= 0 or param.value > 1000:\n                    result.successful = False\n                    result.reason = f'Control frequency must be between 0 and 1000, got {param.value}'\n                    self.get_logger().error(result.reason)\n                    break\n\n            elif param.name == 'max_torque':\n                if param.value <= 0 or param.value > 100:\n                    result.successful = False\n                    result.reason = f'Max torque must be between 0 and 100, got {param.value}'\n                    self.get_logger().error(result.reason)\n                    break\n\n        return result\n"})}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-parameter-reconfiguration",children:"Dynamic Parameter Reconfiguration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rclpy.node import Node\nfrom rcl_interfaces.msg import ParameterDescriptor\nfrom rcl_interfaces.msg import SetParametersResult\nimport threading\n\nclass DynamicReconfigNode(Node):\n    def __init__(self):\n        super().__init__('dynamic_reconfig_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('kp', 1.0)\n        self.declare_parameter('ki', 0.1)\n        self.declare_parameter('kd', 0.01)\n\n        # Add parameter callback for real-time updates\n        self.add_on_set_parameters_callback(self.parameter_update_callback)\n\n        # Initialize control gains\n        self.kp = self.get_parameter('kp').value\n        self.ki = self.get_parameter('ki').value\n        self.kd = self.get_parameter('kd').value\n\n    def parameter_update_callback(self, parameters):\n        \"\"\"Callback for parameter updates\"\"\"\n        result = SetParametersResult()\n        result.successful = True\n\n        for param in parameters:\n            if param.name == 'kp':\n                self.kp = param.value\n                self.get_logger().info(f'Updated kp to {self.kp}')\n            elif param.name == 'ki':\n                self.ki = param.value\n                self.get_logger().info(f'Updated ki to {self.ki}')\n            elif param.name == 'kd':\n                self.kd = param.value\n                self.get_logger().info(f'Updated kd to {self.kd}')\n\n        return result\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-launch-systems",children:"Advanced Launch Systems"}),"\n",(0,a.jsx)(n.h3,{id:"complex-launch-files",children:"Complex Launch Files"}),"\n",(0,a.jsx)(n.p,{children:"Launch files in ROS 2 use Python to provide powerful configuration capabilities:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, LogInfo\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch.conditions import IfCondition\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time', default='false')\n    robot_name = LaunchConfiguration('robot_name', default='humanoid_robot')\n    config_file = LaunchConfiguration('config_file')\n\n    # Declare launch arguments\n    declare_use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='false',\n        description='Use simulation (Gazebo) clock if true'\n    )\n\n    declare_robot_name = DeclareLaunchArgument(\n        'robot_name',\n        default_value='humanoid_robot',\n        description='Name of the robot'\n    )\n\n    declare_config_file = DeclareLaunchArgument(\n        'config_file',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('my_robot_description'),\n            'config',\n            'robot_config.yaml'\n        ]),\n        description='Path to the robot configuration file'\n    )\n\n    # Create nodes\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time},\n            {'robot_description': PathJoinSubstitution([\n                FindPackageShare('my_robot_description'),\n                'urdf',\n                'robot.urdf.xacro'\n            ])},\n            config_file\n        ],\n        remappings=[\n            ('/tf', 'tf'),\n            ('/tf_static', 'tf_static')\n        ]\n    )\n\n    joint_state_publisher = Node(\n        package='joint_state_publisher',\n        executable='joint_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time}\n        ]\n    )\n\n    controller_manager = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[\n            {'use_sim_time': use_sim_time},\n            config_file\n        ],\n        remappings=[\n            ('/tf', 'tf'),\n            ('/tf_static', 'tf_static')\n        ]\n    )\n\n    # Return the launch description\n    return LaunchDescription([\n        declare_use_sim_time,\n        declare_robot_name,\n        declare_config_file,\n        robot_state_publisher,\n        joint_state_publisher,\n        controller_manager,\n    ])\n"})}),"\n",(0,a.jsx)(n.h3,{id:"conditional-launch",children:"Conditional Launch"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, SetEnvironmentVariable\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch.conditions import IfCondition, UnlessCondition\n\ndef generate_launch_description():\n    # Launch arguments\n    use_gazebo = LaunchConfiguration('use_gazebo', default='false')\n    use_real_robot = LaunchConfiguration('use_real_robot', default='false')\n\n    # Conditional launch descriptions\n    gazebo_launch = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        condition=IfCondition(use_gazebo)\n    )\n\n    robot_driver_launch = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('my_robot_driver'),\n                'launch',\n                'robot_driver.launch.py'\n            ])\n        ]),\n        condition=IfCondition(use_real_robot)\n    )\n\n    return LaunchDescription([\n        gazebo_launch,\n        robot_driver_launch,\n    ])\n"})}),"\n",(0,a.jsx)(n.h3,{id:"launch-testing",children:"Launch Testing"}),"\n",(0,a.jsx)(n.p,{children:"Launch testing allows you to test your launch files:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import launch\nfrom launch_ros.actions import Node\nfrom launch_testing.actions import ReadyToTest\nimport launch_testing_ros\nimport pytest\n\ndef generate_test_description():\n    # Create a test node\n    test_node = Node(\n        package='my_robot_package',\n        executable='test_node',\n        name='test_node'\n    )\n\n    return launch.LaunchDescription([\n        test_node,\n        ReadyToTest(),\n    ]), {'test_node': test_node}\n\n# Test function\n@pytest.mark.launch_test\ndef test_node_launch(test_node):\n    assert test_node is not None\n"})}),"\n",(0,a.jsx)(n.h2,{id:"testing-in-ros-2",children:"Testing in ROS 2"}),"\n",(0,a.jsx)(n.h3,{id:"unit-testing-with-pytest",children:"Unit Testing with pytest"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import pytest\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass TestNode(Node):\n    def __init__(self):\n        super().__init__('test_node')\n        self.publisher = self.create_publisher(String, 'test_topic', 10)\n        self.subscription = self.create_subscription(\n            String,\n            'test_topic',\n            self.callback,\n            10\n        )\n        self.received_message = None\n\n    def callback(self, msg):\n        self.received_message = msg.data\n\ndef test_publisher_subscriber():\n    rclpy.init()\n    try:\n        node = TestNode()\n\n        # Publish a message\n        msg = String()\n        msg.data = 'test_message'\n        node.publisher.publish(msg)\n\n        # Spin to process the message\n        rclpy.spin_once(node, timeout_sec=0.1)\n\n        # Check if the message was received\n        assert node.received_message == 'test_message'\n    finally:\n        rclpy.shutdown()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import unittest\nimport rclpy\nfrom rclpy.executors import SingleThreadedExecutor\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom example_interfaces.srv import AddTwoInts\n\nclass PublisherNode(Node):\n    def __init__(self):\n        super().__init__('publisher_node')\n        self.publisher = self.create_publisher(String, 'test_topic', 10)\n\nclass ServiceNode(Node):\n    def __init__(self):\n        super().__init__('service_node')\n        self.srv = self.create_service(\n            AddTwoInts,\n            'add_two_ints',\n            self.add_callback\n        )\n\n    def add_callback(self, request, response):\n        response.sum = request.a + request.b\n        return response\n\nclass TestIntegration(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        self.publisher_node = PublisherNode()\n        self.service_node = ServiceNode()\n        self.executor = SingleThreadedExecutor()\n        self.executor.add_node(self.publisher_node)\n        self.executor.add_node(self.service_node)\n\n    def tearDown(self):\n        self.executor.shutdown()\n        self.publisher_node.destroy_node()\n        self.service_node.destroy_node()\n\n    def test_service_call(self):\n        # Create client and call service\n        client = self.service_node.create_client(AddTwoInts, 'add_two_ints')\n\n        # Wait for service\n        while not client.wait_for_service(timeout_sec=1.0):\n            self.service_node.get_logger().info('Service not available')\n\n        # Make request\n        request = AddTwoInts.Request()\n        request.a = 2\n        request.b = 3\n\n        future = client.call_async(request)\n        self.executor.spin_until_future_complete(future, timeout_sec=1.0)\n\n        self.assertEqual(future.result().sum, 5)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"mock-testing",children:"Mock Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from unittest.mock import Mock, patch\nimport rclpy\nfrom rclpy.node import Node\n\nclass RobotController(Node):\n    def __init__(self):\n        super().__init__('robot_controller')\n        self.joint_publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n    def move_to_position(self, joint_name, target_position):\n        # Move the robot to the target position\n        current_pos = self.get_current_position(joint_name)\n        while abs(current_pos - target_position) > 0.01:\n            # Move toward target\n            self.publish_joint_command(joint_name, target_position)\n            current_pos = self.get_current_position(joint_name)\n\n    def get_current_position(self, joint_name):\n        # This would normally get position from hardware\n        pass\n\n    def publish_joint_command(self, joint_name, position):\n        # Publish command to joint\n        pass\n\ndef test_move_to_position():\n    # Create a mock node\n    with patch('rclpy.node.Node'):\n        controller = RobotController()\n\n        # Mock the methods\n        controller.get_current_position = Mock(return_value=0.0)\n        controller.publish_joint_command = Mock()\n\n        # Test the method\n        controller.move_to_position('joint1', 1.0)\n\n        # Assert that the command was published\n        controller.publish_joint_command.assert_called()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"design-patterns-for-robotic-systems",children:"Design Patterns for Robotic Systems"}),"\n",(0,a.jsx)(n.h3,{id:"state-machine-pattern",children:"State Machine Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from enum import Enum\nimport rclpy\nfrom rclpy.node import Node\n\nclass RobotState(Enum):\n    IDLE = 1\n    MOVING = 2\n    GRASPING = 3\n    ERROR = 4\n\nclass StateMachineNode(Node):\n    def __init__(self):\n        super().__init__('state_machine_node')\n        self.current_state = RobotState.IDLE\n        self.state_callbacks = {\n            RobotState.IDLE: self.handle_idle_state,\n            RobotState.MOVING: self.handle_moving_state,\n            RobotState.GRASPING: self.handle_grasping_state,\n            RobotState.ERROR: self.handle_error_state\n        }\n\n    def update_state(self, new_state):\n        if self.current_state != new_state:\n            self.get_logger().info(f'State transition: {self.current_state} -> {new_state}')\n            self.current_state = new_state\n\n    def handle_idle_state(self):\n        # Handle idle state logic\n        pass\n\n    def handle_moving_state(self):\n        # Handle moving state logic\n        pass\n\n    def handle_grasping_state(self):\n        # Handle grasping state logic\n        pass\n\n    def handle_error_state(self):\n        # Handle error state logic\n        pass\n\n    def run_state_machine(self):\n        # Execute the current state's handler\n        handler = self.state_callbacks[self.current_state]\n        handler()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"observer-pattern",children:"Observer Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\n\nclass ObservableNode(Node):\n    def __init__(self):\n        super().__init__('observable_node')\n        self.observers = []\n        self.joint_states = []\n\n    def add_observer(self, observer):\n        self.observers.append(observer)\n\n    def remove_observer(self, observer):\n        if observer in self.observers:\n            self.observers.remove(observer)\n\n    def notify_observers(self, data):\n        for observer in self.observers:\n            observer.update(data)\n\n    def joint_state_callback(self, msg):\n        self.joint_states = msg.data\n        self.notify_observers(self.joint_states)\n\nclass JointStateObserver:\n    def __init__(self, node):\n        self.node = node\n\n    def update(self, joint_states):\n        # Handle joint state update\n        self.node.get_logger().info(f'Joint states updated: {joint_states}')\n"})}),"\n",(0,a.jsx)(n.h3,{id:"command-pattern",children:"Command Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from abc import ABC, abstractmethod\nimport rclpy\nfrom rclpy.node import Node\n\nclass Command(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n\n    @abstractmethod\n    def undo(self):\n        pass\n\nclass MoveJointCommand(Command):\n    def __init__(self, robot_controller, joint_name, target_position):\n        self.controller = robot_controller\n        self.joint_name = joint_name\n        self.target_position = target_position\n        self.previous_position = None\n\n    def execute(self):\n        self.previous_position = self.controller.get_joint_position(self.joint_name)\n        self.controller.move_joint(self.joint_name, self.target_position)\n\n    def undo(self):\n        if self.previous_position is not None:\n            self.controller.move_joint(self.joint_name, self.previous_position)\n\nclass RobotController(Node):\n    def __init__(self):\n        super().__init__('robot_controller')\n        self.command_history = []\n\n    def execute_command(self, command):\n        command.execute()\n        self.command_history.append(command)\n\n    def undo_last_command(self):\n        if self.command_history:\n            last_command = self.command_history.pop()\n            last_command.undo()\n\n    def get_joint_position(self, joint_name):\n        # Get current joint position\n        pass\n\n    def move_joint(self, joint_name, position):\n        # Move joint to position\n        pass\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"efficient-message-handling",children:"Efficient Message Handling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nimport collections\n\nclass OptimizedNode(Node):\n    def __init__(self):\n        super().__init__('optimized_node')\n\n        # Use deque for efficient message buffering\n        self.joint_state_buffer = collections.deque(maxlen=10)\n\n        # Subscribe with appropriate QoS\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10,  # Queue size\n            # Use sensor data QoS for sensor messages\n            # qos_profile=qos_profile_sensor_data\n        )\n\n        # Timer for processing batches\n        self.process_timer = self.create_timer(0.01, self.process_joint_states)\n\n    def joint_state_callback(self, msg):\n        # Store message in buffer\n        self.joint_state_buffer.append(msg)\n\n    def process_joint_states(self):\n        # Process multiple messages at once\n        while self.joint_state_buffer:\n            msg = self.joint_state_buffer.popleft()\n            # Process the message\n            self.process_single_message(msg)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nimport numpy as np\n\nclass MemoryEfficientNode(Node):\n    def __init__(self):\n        super().__init__('memory_efficient_node')\n\n        # Pre-allocate message objects\n        self.processed_image_msg = Image()\n        self.processed_image_data = None\n\n        self.subscription = self.create_subscription(\n            Image,\n            'camera/image_raw',\n            self.image_callback,\n            1\n        )\n\n    def image_callback(self, msg):\n        # Convert ROS image to numpy array\n        image_data = np.frombuffer(msg.data, dtype=np.uint8)\n        image_data = image_data.reshape((msg.height, msg.width, -1))\n\n        # Process image\n        processed_data = self.process_image(image_data)\n\n        # Reuse message object\n        self.processed_image_msg.header = msg.header\n        self.processed_image_msg.height = processed_data.shape[0]\n        self.processed_image_msg.width = processed_data.shape[1]\n        self.processed_image_msg.encoding = msg.encoding\n        self.processed_image_msg.is_bigendian = msg.is_bigendian\n        self.processed_image_msg.step = processed_data.shape[1] * processed_data.dtype.itemsize\n        self.processed_image_msg.data = processed_data.tobytes()\n\n        # Publish processed image\n        # self.publisher.publish(self.processed_image_msg)\n\n    def process_image(self, image):\n        # Process the image efficiently\n        return image  # Placeholder\n"})}),"\n",(0,a.jsx)(n.h2,{id:"testing-strategies-for-humanoid-robotics",children:"Testing Strategies for Humanoid Robotics"}),"\n",(0,a.jsx)(n.h3,{id:"hardware-in-the-loop-testing",children:"Hardware-in-the-Loop Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import unittest\nfrom unittest.mock import Mock, patch\nimport rclpy\nfrom rclpy.node import Node\n\nclass HardwareInterfaceMock:\n    def __init__(self):\n        self.joint_positions = {}\n        self.joint_velocities = {}\n        self.joint_efforts = {}\n\n    def read_joint_state(self, joint_name):\n        return (\n            self.joint_positions.get(joint_name, 0.0),\n            self.joint_velocities.get(joint_name, 0.0),\n            self.joint_efforts.get(joint_name, 0.0)\n        )\n\n    def write_joint_command(self, joint_name, position, velocity=0.0, effort=0.0):\n        # Simulate writing to hardware\n        pass\n\nclass TestHumanoidController(unittest.TestCase):\n    def setUp(self):\n        rclpy.init()\n        self.hardware_mock = HardwareInterfaceMock()\n\n        # Patch the hardware interface\n        with patch('my_robot_hardware.HardwareInterface', return_value=self.hardware_mock):\n            self.controller = HumanoidController()\n\n    def tearDown(self):\n        self.controller.destroy_node()\n        rclpy.shutdown()\n\n    def test_balance_controller(self):\n        # Set up initial conditions\n        self.hardware_mock.joint_positions = {\n            'left_hip': 0.0,\n            'right_hip': 0.0,\n            'left_knee': 0.0,\n            'right_knee': 0.0\n        }\n\n        # Run the balance controller\n        result = self.controller.run_balance_step()\n\n        # Verify the expected behavior\n        self.assertTrue(result.success)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"simulation-testing",children:"Simulation Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import unittest\nimport rclpy\nfrom rclpy.node import Node\nfrom builtin_interfaces.msg import Duration\n\nclass SimulationTestNode(Node):\n    def __init__(self):\n        super().__init__(\'simulation_test_node\')\n        self.sim_time = 0.0\n\n    def wait_for_condition(self, condition_func, timeout=10.0):\n        """Wait for a condition to be true in simulation time"""\n        start_time = self.sim_time\n        while self.sim_time - start_time < timeout:\n            if condition_func():\n                return True\n            # In simulation, we might need to step the clock\n            # This is a simplified example\n        return False\n\ndef test_walking_pattern():\n    rclpy.init()\n    try:\n        node = SimulationTestNode()\n\n        # Set up the walking controller\n        walker = WalkingController(node)\n\n        # Start walking\n        walker.start_walking()\n\n        # Wait for the robot to take a step\n        success = node.wait_for_condition(\n            lambda: walker.get_step_count() > 0,\n            timeout=5.0\n        )\n\n        assert success, "Robot did not take a step within timeout"\n\n        # Verify final position\n        final_pos = walker.get_robot_position()\n        assert final_pos.x > 0.0, "Robot did not move forward"\n\n    finally:\n        rclpy.shutdown()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use YAML files for complex configurations"}),"\n",(0,a.jsx)(n.li,{children:"Validate parameters at startup"}),"\n",(0,a.jsx)(n.li,{children:"Use parameter descriptors for constraints"}),"\n",(0,a.jsx)(n.li,{children:"Implement parameter change callbacks"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Write unit tests for individual components"}),"\n",(0,a.jsx)(n.li,{children:"Create integration tests for subsystems"}),"\n",(0,a.jsx)(n.li,{children:"Use mocking to isolate dependencies"}),"\n",(0,a.jsx)(n.li,{children:"Implement continuous integration"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"performance-best-practices",children:"Performance Best Practices"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Profile your nodes to identify bottlenecks"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate QoS settings"}),"\n",(0,a.jsx)(n.li,{children:"Implement efficient data structures"}),"\n",(0,a.jsx)(n.li,{children:"Consider threading for I/O operations"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"Advanced ROS 2 patterns provide the tools needed to build complex, robust robotic systems. Proper parameter management, launch systems, and testing strategies are essential for humanoid robotics applications. These patterns enable the development of maintainable, scalable, and reliable robotic systems that can handle the complexity of humanoid robots."}),"\n",(0,a.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create a launch file that starts a complete humanoid robot system with multiple controllers"}),"\n",(0,a.jsx)(n.li,{children:"Implement a state machine for a humanoid robot's walking behavior"}),"\n",(0,a.jsx)(n.li,{children:"Write unit tests for a humanoid robot's balance controller"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.p,{children:['[1] ROS 2 Documentation, "Launch System," ',(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/p/launch/",children:"https://docs.ros.org/en/rolling/p/launch/"})]}),"\n",(0,a.jsxs)(n.p,{children:['[2] ROS 2 Documentation, "Testing," ',(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/How-To-Guides/Testing/",children:"https://docs.ros.org/en/rolling/How-To-Guides/Testing/"})]}),"\n",(0,a.jsxs)(n.p,{children:['[3] ROS 2 Documentation, "Parameters," ',(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/How-To-Guides/Using-Parameters-in-a-class-CPP.html",children:"https://docs.ros.org/en/rolling/How-To-Guides/Using-Parameters-in-a-class-CPP.html"})]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);