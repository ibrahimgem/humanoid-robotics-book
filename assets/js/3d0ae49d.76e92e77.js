"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[9539],{28453:(n,e,o)=>{o.d(e,{R:()=>r,x:()=>s});var i=o(96540);const t={},a=i.createContext(t);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),i.createElement(a.Provider,{value:e},n.children)}},40621:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-3-simulation-environments/gazebo-simulation-humanoids","title":"Chapter 3.1 - Gazebo Simulation for Humanoids","description":"Physics-Based Simulation with Gazebo","source":"@site/docs/module-3-simulation-environments/gazebo-simulation-humanoids.mdx","sourceDirName":"module-3-simulation-environments","slug":"/module-3-simulation-environments/gazebo-simulation-humanoids","permalink":"/humanoid-robotics-book/docs/module-3-simulation-environments/gazebo-simulation-humanoids","draft":false,"unlisted":false,"editUrl":"https://github.com/ibrahimgem/humanoid-robotics-book/edit/main/docs/module-3-simulation-environments/gazebo-simulation-humanoids.mdx","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11,"title":"Chapter 3.1 - Gazebo Simulation for Humanoids","description":"Physics-Based Simulation with Gazebo"},"sidebar":"tutorialSidebar","previous":{"title":"Module 3 - Simulation Environments","permalink":"/humanoid-robotics-book/docs/module-3-simulation-environments/"},"next":{"title":"Chapter 3.2 - Unity Robotics Hub","permalink":"/humanoid-robotics-book/docs/module-3-simulation-environments/unity-robotics-hub"}}');var t=o(74848),a=o(28453);const r={sidebar_position:11,title:"Chapter 3.1 - Gazebo Simulation for Humanoids",description:"Physics-Based Simulation with Gazebo"},s="Chapter 3.1: Gazebo Simulation for Humanoids",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Gazebo Architecture",id:"gazebo-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Gazebo vs. Gazebo Classic",id:"gazebo-vs-gazebo-classic",level:3},{value:"Setting Up Gazebo for Humanoid Robots",id:"setting-up-gazebo-for-humanoid-robots",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Launch",id:"basic-launch",level:3},{value:"Creating Humanoid Robot Models for Gazebo",id:"creating-humanoid-robot-models-for-gazebo",level:2},{value:"Gazebo-Specific URDF Extensions",id:"gazebo-specific-urdf-extensions",level:3},{value:"Physics Configuration for Humanoid Robots",id:"physics-configuration-for-humanoid-robots",level:2},{value:"Contact Parameters",id:"contact-parameters",level:3},{value:"Inertial Parameters",id:"inertial-parameters",level:3},{value:"Gazebo Controllers for Humanoid Robots",id:"gazebo-controllers-for-humanoid-robots",level:2},{value:"Joint State Controller",id:"joint-state-controller",level:3},{value:"Position and Effort Controllers",id:"position-and-effort-controllers",level:3},{value:"Launching Humanoid Robot in Gazebo",id:"launching-humanoid-robot-in-gazebo",level:2},{value:"Complete Launch File",id:"complete-launch-file",level:3},{value:"Advanced Gazebo Features for Humanoids",id:"advanced-gazebo-features-for-humanoids",level:2},{value:"Custom Physics Plugins",id:"custom-physics-plugins",level:3},{value:"Terrain and Environment Setup",id:"terrain-and-environment-setup",level:3},{value:"Debugging and Visualization",id:"debugging-and-visualization",level:2},{value:"TF Tree Visualization",id:"tf-tree-visualization",level:3},{value:"Joint State Monitoring",id:"joint-state-monitoring",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Simulation Parameters",id:"simulation-parameters",level:3},{value:"Model Simplification",id:"model-simplification",level:3},{value:"Best Practices for Humanoid Simulation",id:"best-practices-for-humanoid-simulation",level:2},{value:"Stability Considerations",id:"stability-considerations",level:3},{value:"Model Quality",id:"model-quality",level:3},{value:"Testing Strategies",id:"testing-strategies",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Robot Falling Through Ground",id:"robot-falling-through-ground",level:3},{value:"Unstable Joint Control",id:"unstable-joint-control",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-31-gazebo-simulation-for-humanoids",children:"Chapter 3.1: Gazebo Simulation for Humanoids"})}),"\n",(0,t.jsx)(e.h2,{id:"goal",children:"Goal"}),"\n",(0,t.jsx)(e.p,{children:"Learn to set up and use Gazebo for humanoid robot simulation with realistic physics."}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"After completing this chapter, students will create simulation environments for humanoid robots with accurate physics."}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo is a powerful physics-based simulation environment that has been widely adopted in robotics research and development. It provides realistic simulation of robots in complex environments, including accurate physics, sensor simulation, and rendering capabilities. For humanoid robotics, Gazebo offers the ability to test complex locomotion algorithms, manipulation tasks, and human-robot interaction scenarios in a safe and repeatable environment."}),"\n",(0,t.jsx)(e.h2,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo consists of several key components that work together to provide a comprehensive simulation environment:"}),"\n",(0,t.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics Engine"}),": Handles collision detection and response, using engines like ODE, Bullet, or DART"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Simulation"}),": Models various sensors including cameras, LIDAR, IMU, and force/torque sensors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rendering Engine"}),": Provides 3D visualization using OGRE"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Plugin System"}),": Allows customization and extension of simulation capabilities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS Integration"}),": Seamless integration with ROS through gazebo_ros_pkgs"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-vs-gazebo-classic",children:"Gazebo vs. Gazebo Classic"}),"\n",(0,t.jsx)(e.p,{children:'Historically, Gazebo Classic (formerly just "Gazebo") was the standard. However, the newer Gazebo (often called Garden or Fortress) has been rewritten with better performance and features. For humanoid robotics, both are viable options, though newer versions offer better performance and features.'}),"\n",(0,t.jsx)(e.h2,{id:"setting-up-gazebo-for-humanoid-robots",children:"Setting Up Gazebo for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(e.p,{children:"For ROS 2 integration, install the appropriate gazebo_ros_pkgs:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# For Humble Hawksbill (or your ROS 2 distribution)\nsudo apt install ros-humble-gazebo-ros-pkgs\nsudo apt install ros-humble-gazebo-ros2-control\nsudo apt install ros-humble-ros2-control\nsudo apt install ros-humble-ros2-controllers\n"})}),"\n",(0,t.jsx)(e.h3,{id:"basic-launch",children:"Basic Launch"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"\x3c!-- launch/gazebo.launch.py --\x3e\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ])\n    )\n\n    return LaunchDescription([\n        gazebo\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"creating-humanoid-robot-models-for-gazebo",children:"Creating Humanoid Robot Models for Gazebo"}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-specific-urdf-extensions",children:"Gazebo-Specific URDF Extensions"}),"\n",(0,t.jsx)(e.p,{children:"To make your humanoid robot work properly in Gazebo, you need to add Gazebo-specific tags to your URDF:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Include the basic robot definition --\x3e\n  <xacro:include filename="$(find my_robot_description)/urdf/robot.urdf.xacro"/>\n\n  \x3c!-- Gazebo plugin for ROS control --\x3e\n  <gazebo>\n    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n      <parameters>$(find my_robot_controller)/config/robot_controllers.yaml</parameters>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Gazebo materials --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Blue</material>\n    <mu1>0.2</mu1>\n    <mu2>0.2</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n  </gazebo>\n\n  \x3c!-- Sensor plugins --\x3e\n  <gazebo reference="camera_link">\n    <sensor name="camera" type="camera">\n      <pose>0 0 0 0 0 0</pose>\n      <camera>\n        <horizontal_fov>1.047</horizontal_fov>\n        <image>\n          <width>640</width>\n          <height>480</height>\n          <format>R8G8B8</format>\n        </image>\n        <clip>\n          <near>0.1</near>\n          <far>100</far>\n        </clip>\n      </camera>\n      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n        <frame_name>camera_optical_frame</frame_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- IMU sensor --\x3e\n  <gazebo reference="imu_link">\n    <sensor name="imu_sensor" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <visualize>true</visualize>\n      <imu>\n        <angular_velocity>\n          <x>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n            </noise>\n          </x>\n          <y>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n            </noise>\n          </y>\n          <z>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n            </noise>\n          </z>\n        </angular_velocity>\n        <linear_acceleration>\n          <x>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n            </noise>\n          </x>\n          <y>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n            </noise>\n          </y>\n          <z>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n            </noise>\n          </z>\n        </linear_acceleration>\n      </imu>\n    </sensor>\n  </gazebo>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"physics-configuration-for-humanoid-robots",children:"Physics Configuration for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"contact-parameters",children:"Contact Parameters"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots, proper contact parameters are crucial for stable simulation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="left_foot">\n  <kp>100000000.0</kp>  \x3c!-- High stiffness for stable contacts --\x3e\n  <kd>1000000.0</kd>    \x3c!-- Damping to reduce oscillations --\x3e\n  <mu1>0.8</mu1>        \x3c!-- Friction coefficient --\x3e\n  <mu2>0.8</mu2>        \x3c!-- Secondary friction coefficient --\x3e\n  <max_vel>100.0</max_vel>\n  <min_depth>0.001</min_depth>  \x3c!-- Minimum contact depth --\x3e\n</gazebo>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"inertial-parameters",children:"Inertial Parameters"}),"\n",(0,t.jsx)(e.p,{children:"Accurate inertial parameters are essential for realistic physics simulation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<link name="torso">\n  <inertial>\n    <mass value="10.0"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n    <inertia\n      ixx="0.333"\n      ixy="0.0"\n      ixz="0.0"\n      iyy="0.333"\n      iyz="0.0"\n      izz="0.333"/>\n  </inertial>\n</link>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"gazebo-controllers-for-humanoid-robots",children:"Gazebo Controllers for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"joint-state-controller",children:"Joint State Controller"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# config/joint_state_controller.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_controller:\n      type: joint_state_controller/JointStateController\n\njoint_state_controller:\n  ros__parameters:\n    publish_rate: 50\n"})}),"\n",(0,t.jsx)(e.h3,{id:"position-and-effort-controllers",children:"Position and Effort Controllers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# config/humanoid_controllers.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100\n\n    joint_state_controller:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    left_leg_controller:\n      type: position_controllers/JointGroupPositionController\n\n    right_leg_controller:\n      type: position_controllers/JointGroupPositionController\n\n    left_arm_controller:\n      type: position_controllers/JointGroupPositionController\n\n    right_arm_controller:\n      type: position_controllers/JointGroupPositionController\n\nleft_leg_controller:\n  ros__parameters:\n    joints:\n      - left_hip_joint\n      - left_knee_joint\n      - left_ankle_joint\n\nright_leg_controller:\n  ros__parameters:\n    joints:\n      - right_hip_joint\n      - right_knee_joint\n      - right_ankle_joint\n\nleft_arm_controller:\n  ros__parameters:\n    joints:\n      - left_shoulder_joint\n      - left_elbow_joint\n\nright_arm_controller:\n  ros__parameters:\n    joints:\n      - right_shoulder_joint\n      - right_elbow_joint\n"})}),"\n",(0,t.jsx)(e.h2,{id:"launching-humanoid-robot-in-gazebo",children:"Launching Humanoid Robot in Gazebo"}),"\n",(0,t.jsx)(e.h3,{id:"complete-launch-file",children:"Complete Launch File"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# launch/humanoid_gazebo.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, DeclareLaunchArgument, RegisterEventHandler\nfrom launch.event_handlers import OnProcessExit\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import Command, FindExecutable, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare arguments\n    declared_arguments = []\n    declared_arguments.append(\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='true',\n            description='Use simulation time instead of real time'\n        )\n    )\n\n    # Get URDF via xacro\n    robot_description_content = Command(\n        [\n            PathJoinSubstitution([FindExecutable(name='xacro')]),\n            ' ',\n            PathJoinSubstitution(\n                [FindPackageShare('my_robot_description'), 'urdf', 'humanoid.urdf.xacro']\n            ),\n        ]\n    )\n    robot_description = {'robot_description': robot_description_content}\n\n    # Spawn robot in Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='both',\n        parameters=[robot_description],\n    )\n\n    # Spawn robot\n    spawn_robot = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=['-topic', 'robot_description', '-entity', 'humanoid_robot'],\n        output='screen',\n    )\n\n    # Load and activate controllers\n    load_joint_state_controller = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\n             'joint_state_controller'],\n        output='screen'\n    )\n\n    return LaunchDescription(\n        declared_arguments +\n        [\n            gazebo,\n            robot_state_publisher,\n            spawn_robot,\n            RegisterEventHandler(\n                OnProcessExit(\n                    target_action=spawn_robot,\n                    on_exit=[load_joint_state_controller],\n                )\n            ),\n        ]\n    )\n"})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-gazebo-features-for-humanoids",children:"Advanced Gazebo Features for Humanoids"}),"\n",(0,t.jsx)(e.h3,{id:"custom-physics-plugins",children:"Custom Physics Plugins"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid-specific physics, you might need custom plugins:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Custom balance plugin example\n#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/common/common.hh>\n#include <ignition/math/Pose3.hh>\n\nnamespace gazebo\n{\n  class HumanoidBalancePlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)\n    {\n      // Store the model pointer for convenience\n      this->model = _parent;\n\n      // Listen to the update event. This event is broadcast every\n      // simulation iteration.\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n          std::bind(&HumanoidBalancePlugin::OnUpdate, this));\n    }\n\n    // Called by the world update start event\n    public: void OnUpdate()\n    {\n      // Apply balance forces based on COM position\n      // Implementation would include PID controllers for balance\n    }\n\n    private: physics::ModelPtr model;\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  // Register this plugin with the simulator\n  GZ_REGISTER_MODEL_PLUGIN(HumanoidBalancePlugin)\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"terrain-and-environment-setup",children:"Terrain and Environment Setup"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid locomotion, realistic terrain is important:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sdf",children:'\x3c!-- world file example --\x3e\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Include ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include sun --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Custom terrain for walking --\x3e\n    <model name="uneven_terrain">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <heightmap>\n              <uri>file://media/materials/textures/uneven_terrain.png</uri>\n              <size>10 10 2</size>\n            </heightmap>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <heightmap>\n              <uri>file://media/materials/textures/uneven_terrain.png</uri>\n              <size>10 10 2</size>\n            </heightmap>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Obstacles for navigation --\x3e\n    <model name="obstacle_1">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"debugging-and-visualization",children:"Debugging and Visualization"}),"\n",(0,t.jsx)(e.h3,{id:"tf-tree-visualization",children:"TF Tree Visualization"}),"\n",(0,t.jsx)(e.p,{children:"In Gazebo, you can visualize the TF tree to debug your humanoid robot's kinematics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Visualize TF tree\nros2 run tf2_tools view_frames\n\n# Echo TF transforms\nros2 run tf2_ros tf2_echo base_link left_foot\n"})}),"\n",(0,t.jsx)(e.h3,{id:"joint-state-monitoring",children:"Joint State Monitoring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Monitor joint states\nros2 topic echo /joint_states sensor_msgs/msg/JointState\n"})}),"\n",(0,t.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(e.h3,{id:"simulation-parameters",children:"Simulation Parameters"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots with many degrees of freedom, performance optimization is important:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- physics parameters in world file --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>  \x3c!-- Smaller steps for stability --\x3e\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>10</iters>  \x3c!-- Reduce iterations for performance --\x3e\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.000001</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"model-simplification",children:"Model Simplification"}),"\n",(0,t.jsx)(e.p,{children:"For performance, consider simplified collision models:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Use simpler collision geometry for simulation --\x3e\n<link name="upper_arm">\n  <collision>\n    \x3c!-- Use cylinder instead of complex mesh for collision --\x3e\n    <geometry>\n      <cylinder radius="0.05" length="0.4"/>\n    </geometry>\n  </collision>\n  <visual>\n    \x3c!-- Keep detailed mesh for visualization --\x3e\n    <geometry>\n      <mesh filename="package://my_robot_description/meshes/upper_arm.dae"/>\n    </geometry>\n  </visual>\n</link>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-humanoid-simulation",children:"Best Practices for Humanoid Simulation"}),"\n",(0,t.jsx)(e.h3,{id:"stability-considerations",children:"Stability Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use appropriate physics parameters for humanoid balance"}),"\n",(0,t.jsx)(e.li,{children:"Implement proper joint limits and safety controllers"}),"\n",(0,t.jsx)(e.li,{children:"Test with various terrain types"}),"\n",(0,t.jsx)(e.li,{children:"Validate simulation against real robot when possible"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"model-quality",children:"Model Quality"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Ensure mass properties are realistic"}),"\n",(0,t.jsx)(e.li,{children:"Use appropriate friction coefficients"}),"\n",(0,t.jsx)(e.li,{children:"Implement proper sensor noise models"}),"\n",(0,t.jsx)(e.li,{children:"Include gear ratios and motor dynamics if needed"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Start with simple movements before complex behaviors"}),"\n",(0,t.jsx)(e.li,{children:"Test balance controllers in simulation first"}),"\n",(0,t.jsx)(e.li,{children:"Use simulation to tune controller parameters"}),"\n",(0,t.jsx)(e.li,{children:"Implement safety stops to prevent simulation crashes"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,t.jsx)(e.h3,{id:"robot-falling-through-ground",children:"Robot Falling Through Ground"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Ensure proper collision geometry and physics parameters --\x3e\n<gazebo reference="base_link">\n  <kp>1000000.0</kp>\n  <kd>1000.0</kd>\n  <mu1>1.0</mu1>\n  <mu2>1.0</mu2>\n</gazebo>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"unstable-joint-control",children:"Unstable Joint Control"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Check controller update rates"}),"\n",(0,t.jsx)(e.li,{children:"Verify PID parameters"}),"\n",(0,t.jsx)(e.li,{children:"Ensure proper joint limits"}),"\n",(0,t.jsx)(e.li,{children:"Validate transmission configurations"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo provides a powerful platform for humanoid robot simulation with realistic physics. Proper configuration of physics parameters, controllers, and sensors is essential for meaningful simulation results. The ability to test complex behaviors in simulation before deploying on real hardware makes Gazebo an invaluable tool for humanoid robotics development."}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create a Gazebo simulation environment for a humanoid robot with proper physics parameters"}),"\n",(0,t.jsx)(e.li,{children:"Implement a simple walking pattern in simulation and observe the results"}),"\n",(0,t.jsx)(e.li,{children:"Add sensors (camera, IMU) to your humanoid robot model and verify they work in simulation"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(e.p,{children:'[1] J. Morrison, "Gazebo: A 3D Multi-Robot Simulator," Gazebo.org, 2012.'}),"\n",(0,t.jsxs)(e.p,{children:['[2] ROS Documentation, "Gazebo with ROS 2," ',(0,t.jsx)(e.a,{href:"https://classic.gazebosim.org/tutorials?cat=connect_ros",children:"https://classic.gazebosim.org/tutorials?cat=connect_ros"})]}),"\n",(0,t.jsx)(e.p,{children:'[3] C. D. Lu, "Physics Simulation for Robotic Applications," IEEE Robotics & Automation Magazine, vol. 23, no. 1, pp. 39-49, 2016.'})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);