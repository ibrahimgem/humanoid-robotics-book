"use strict";(self.webpackChunkhumanoid_robotics_book=self.webpackChunkhumanoid_robotics_book||[]).push([[3503],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>r});var t=i(96540);const o={},s=t.createContext(o);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(s.Provider,{value:e},n.children)}},57302:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-nvidia-isaac/isaac-sim-fundamentals","title":"Chapter 4.1 - Isaac Sim Fundamentals","description":"NVIDIA Isaac Sim Architecture and Usage","source":"@site/docs/module-4-nvidia-isaac/isaac-sim-fundamentals.mdx","sourceDirName":"module-4-nvidia-isaac","slug":"/module-4-nvidia-isaac/isaac-sim-fundamentals","permalink":"/humanoid-robotics-book/docs/module-4-nvidia-isaac/isaac-sim-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/ibrahimgem/humanoid-robotics-book/edit/main/docs/module-4-nvidia-isaac/isaac-sim-fundamentals.mdx","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16,"title":"Chapter 4.1 - Isaac Sim Fundamentals","description":"NVIDIA Isaac Sim Architecture and Usage"},"sidebar":"tutorialSidebar","previous":{"title":"Module 4 - NVIDIA Isaac Platform","permalink":"/humanoid-robotics-book/docs/module-4-nvidia-isaac/"},"next":{"title":"Chapter 4.2 - Isaac ROS Integration","permalink":"/humanoid-robotics-book/docs/module-4-nvidia-isaac/isaac-ros-integration"}}');var o=i(74848),s=i(28453);const a={sidebar_position:16,title:"Chapter 4.1 - Isaac Sim Fundamentals",description:"NVIDIA Isaac Sim Architecture and Usage"},r="Chapter 4.1: Isaac Sim Fundamentals",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Isaac Sim Architecture",id:"isaac-sim-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Omniverse and USD Integration",id:"omniverse-and-usd-integration",level:3},{value:"Setting Up Isaac Sim",id:"setting-up-isaac-sim",level:2},{value:"Installation and Prerequisites",id:"installation-and-prerequisites",level:3},{value:"Hardware Requirements",id:"hardware-requirements",level:4},{value:"Software Requirements",id:"software-requirements",level:4},{value:"Installation Methods",id:"installation-methods",level:3},{value:"Method 1: Isaac Sim Docker (Recommended)",id:"method-1-isaac-sim-docker-recommended",level:4},{value:"Method 2: Isaac Sim Standalone",id:"method-2-isaac-sim-standalone",level:4},{value:"Isaac Sim Python API",id:"isaac-sim-python-api",level:2},{value:"Basic Scene Setup",id:"basic-scene-setup",level:3},{value:"Robot Loading and Configuration",id:"robot-loading-and-configuration",level:3},{value:"Physics Configuration for Humanoid Robots",id:"physics-configuration-for-humanoid-robots",level:3},{value:"Environment Creation for Humanoid Robots",id:"environment-creation-for-humanoid-robots",level:2},{value:"Basic Environment Setup",id:"basic-environment-setup",level:3},{value:"Advanced Environment Features",id:"advanced-environment-features",level:3},{value:"Sensor Integration in Isaac Sim",id:"sensor-integration-in-isaac-sim",level:2},{value:"Camera Sensors",id:"camera-sensors",level:3},{value:"LIDAR and Other Sensors",id:"lidar-and-other-sensors",level:3},{value:"Simulation Control and Execution",id:"simulation-control-and-execution",level:2},{value:"World Management",id:"world-management",level:3},{value:"Humanoid-Specific Simulation Features",id:"humanoid-specific-simulation-features",level:3},{value:"Best Practices for Isaac Sim",id:"best-practices-for-isaac-sim",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Model Quality and Validation",id:"model-quality-and-validation",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Physics Instability",id:"physics-instability",level:3},{value:"Rendering Performance",id:"rendering-performance",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-41-isaac-sim-fundamentals",children:"Chapter 4.1: Isaac Sim Fundamentals"})}),"\n",(0,o.jsx)(e.h2,{id:"goal",children:"Goal"}),"\n",(0,o.jsx)(e.p,{children:"Learn the core concepts of Isaac Sim for advanced humanoid simulation."}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, students will understand and implement Isaac Sim for humanoid robot simulation."}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"NVIDIA Isaac Sim represents a significant advancement in robotics simulation, providing a comprehensive platform that combines high-fidelity physics simulation with photorealistic rendering. Built on NVIDIA's Omniverse platform, Isaac Sim enables the creation of complex, realistic environments for testing and training humanoid robots. This chapter introduces the fundamental concepts, architecture, and usage patterns essential for leveraging Isaac Sim in humanoid robotics applications."}),"\n",(0,o.jsx)(e.h2,{id:"isaac-sim-architecture",children:"Isaac Sim Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(e.p,{children:"Isaac Sim is built on several key components that work together to provide a powerful simulation environment:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Omniverse Platform"}),": The underlying foundation that provides real-time collaboration, USD-based scene description, and extensible architecture"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"PhysX Physics Engine"}),": NVIDIA's advanced physics simulation engine optimized for robotics applications"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RTX Rendering"}),": Real-time ray tracing for photorealistic visuals"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Isaac Extensions"}),": Specialized tools and frameworks for robotics applications"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ROS 2 Bridge"}),": Seamless integration with ROS 2 for robotics development workflows"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"omniverse-and-usd-integration",children:"Omniverse and USD Integration"}),"\n",(0,o.jsx)(e.p,{children:"Isaac Sim leverages NVIDIA Omniverse and Universal Scene Description (USD) as its core technologies:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"USD (Universal Scene Description)"}),": A scalable scene description composed of asset interchange and composition formats"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"MDL (Material Description Language)"}),": For physically-based material definitions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RTX Real-time Ray Tracing"}),": For photorealistic rendering and sensor simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"PhysX"}),": For accurate physics simulation"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"setting-up-isaac-sim",children:"Setting Up Isaac Sim"}),"\n",(0,o.jsx)(e.h3,{id:"installation-and-prerequisites",children:"Installation and Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Isaac Sim has specific hardware and software requirements:"}),"\n",(0,o.jsx)(e.h4,{id:"hardware-requirements",children:"Hardware Requirements"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GPU"}),": NVIDIA RTX series (RTX 3080 or better recommended)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"VRAM"}),": 10GB+ recommended for complex humanoid scenes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CPU"}),": Multi-core processor (8+ cores)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RAM"}),": 32GB+ recommended"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Storage"}),": SSD with 100GB+ available space"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"software-requirements",children:"Software Requirements"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CUDA"}),": 11.8 or later"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"NVIDIA Driver"}),": 520 or later"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Isaac Sim"}),": Available via NVIDIA NGC or standalone installer"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"installation-methods",children:"Installation Methods"}),"\n",(0,o.jsx)(e.h4,{id:"method-1-isaac-sim-docker-recommended",children:"Method 1: Isaac Sim Docker (Recommended)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:'# Pull the Isaac Sim Docker image\ndocker pull nvcr.io/nvidia/isaac-sim:4.0.0\n\n# Run Isaac Sim container\ndocker run --gpus all -it --rm \\\n  --network=host \\\n  --env "DISPLAY" \\\n  --env "QT_X11_NO_MITSHM=1" \\\n  --volume "/tmp/.X11-unix:/tmp/.X11-unix:rw" \\\n  --volume "/home/$USER/Documents/IsaacSim/projects:/isaac-sim/projects" \\\n  --privileged \\\n  --pid=host \\\n  nvcr.io/nvidia/isaac-sim:4.0.0\n'})}),"\n",(0,o.jsx)(e.h4,{id:"method-2-isaac-sim-standalone",children:"Method 2: Isaac Sim Standalone"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Download from NVIDIA Developer website"}),"\n",(0,o.jsx)(e.li,{children:"Install using Omniverse Launcher"}),"\n",(0,o.jsx)(e.li,{children:"Configure extensions and assets"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"isaac-sim-python-api",children:"Isaac Sim Python API"}),"\n",(0,o.jsx)(e.h3,{id:"basic-scene-setup",children:"Basic Scene Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.articulations import Articulation\n\n# Initialize Isaac Sim\ndef setup_world():\n    """Create and configure the simulation world"""\n    # Create world instance\n    world = World(stage_units_in_meters=1.0)\n\n    # Set default physics parameters\n    world.get_physics_context().set_gravity(9.81)\n    world.get_physics_context().set_simulation_dt(1.0/60.0, substeps=1)\n\n    return world\n\ndef create_basic_scene():\n    """Create a basic scene with ground plane and lighting"""\n    world = setup_world()\n\n    # Get assets root path\n    assets_root_path = get_assets_root_path()\n\n    # Add ground plane\n    add_reference_to_stage(\n        assets_root_path + "/Isaac/Environments/Grid/default_environment.usd",\n        "/World/defaultGround"\n    )\n\n    # Add simple room environment\n    add_reference_to_stage(\n        assets_root_path + "/Isaac/Environments/Simple_Room/simple_room.usd",\n        "/World/Room"\n    )\n\n    return world\n'})}),"\n",(0,o.jsx)(e.h3,{id:"robot-loading-and-configuration",children:"Robot Loading and Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.articulations import Articulation\n\nclass IsaacSimHumanoidRobot:\n    def __init__(self, prim_path, usd_path, position=[0, 0, 1.0], orientation=[0, 0, 0, 1]):\n        self.prim_path = prim_path\n        self.usd_path = usd_path\n        self.position = position\n        self.orientation = orientation\n        self.robot = None\n\n    def load_robot(self):\n        """Load humanoid robot from USD file"""\n        # Add robot reference to stage\n        add_reference_to_stage(\n            usd_path=self.usd_path,\n            prim_path=self.prim_path\n        )\n\n        # Create robot object\n        self.robot = Robot(\n            prim_path=self.prim_path,\n            name=self.prim_path.split("/")[-1],\n            position=self.position,\n            orientation=self.orientation\n        )\n\n        return self.robot\n\n    def setup_controllers(self):\n        """Setup joint controllers for the humanoid robot"""\n        # Get joint names\n        joint_names = self.robot.dof_names\n\n        # Initialize joint controllers\n        self.joint_controllers = {}\n        for joint_name in joint_names:\n            # Create position controller for each joint\n            self.joint_controllers[joint_name] = {\n                \'target_position\': 0.0,\n                \'current_position\': 0.0,\n                \'max_effort\': 100.0,\n                \'control_mode\': \'position\'\n            }\n\n    def move_to_position(self, joint_positions):\n        """Move robot joints to specified positions"""\n        if self.robot:\n            # Set joint positions\n            self.robot.set_joints_state(positions=joint_positions)\n\n    def get_robot_state(self):\n        """Get current state of the robot"""\n        if self.robot:\n            joint_positions = self.robot.get_joints_state().position\n            joint_velocities = self.robot.get_joints_state().velocity\n            base_position, base_orientation = self.robot.get_world_pose()\n\n            return {\n                \'joint_positions\': joint_positions,\n                \'joint_velocities\': joint_velocities,\n                \'base_position\': base_position,\n                \'base_orientation\': base_orientation\n            }\n        return None\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-configuration-for-humanoid-robots",children:"Physics Configuration for Humanoid Robots"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from pxr import PhysxSchema, UsdPhysics, Gf\nfrom omni.isaac.core.utils.prims import get_prim_at_path\n\ndef configure_humanoid_physics(robot_prim_path, robot_mass=75.0):\n    \"\"\"Configure physics properties for humanoid robot\"\"\"\n\n    # Get robot prim\n    robot_prim = get_prim_at_path(robot_prim_path)\n\n    # Enable rigid body dynamics for the robot\n    rigid_body_api = UsdPhysics.RigidBodyAPI.Apply(robot_prim)\n    rigid_body_api.CreateRigidBodyEnabledAttr(True)\n\n    # Configure PhysX properties for stability\n    physx_rigid_body_api = PhysxSchema.PhysxRigidBodyAPI.Apply(robot_prim)\n    physx_rigid_body_api.CreateSleepThresholdAttr(0.001)\n    physx_rigid_body_api.CreateStabilizationThresholdAttr(0.001)\n\n    # Configure mass properties for each link\n    configure_link_masses(robot_prim_path, robot_mass)\n\n    # Configure joint properties for stability\n    configure_joint_properties(robot_prim_path)\n\ndef configure_link_masses(robot_prim_path, total_mass):\n    \"\"\"Distribute mass across humanoid links based on anatomical proportions\"\"\"\n    # Anatomical mass distribution for humanoid\n    mass_distribution = {\n        'pelvis': 0.12,      # 12% of body mass\n        'torso': 0.35,       # 35% of body mass\n        'head': 0.07,        # 7% of body mass\n        'upper_leg_l': 0.10, # 10% each leg\n        'lower_leg_l': 0.05, # 5% each lower leg\n        'foot_l': 0.015,     # 1.5% each foot\n        'upper_arm_l': 0.03, # 3% each arm\n        'lower_arm_l': 0.015 # 1.5% each lower arm\n    }\n\n    # Apply to all links\n    for link_name, mass_ratio in mass_distribution.items():\n        link_path = f\"{robot_prim_path}/{link_name}\"\n        link_prim = get_prim_at_path(link_path)\n\n        if link_prim:\n            mass_api = UsdPhysics.MassAPI.Apply(link_prim)\n            link_mass = total_mass * mass_ratio\n            mass_api.CreateMassAttr(link_mass)\n\n            # Set center of mass\n            mass_api.CreateCenterOfMassAttr(Gf.Vec3f(0, 0, 0))\n\ndef configure_joint_properties(robot_prim_path):\n    \"\"\"Configure joint properties for humanoid stability\"\"\"\n    # Joint limits and damping for humanoid joints\n    joint_config = {\n        # Hip joints\n        'left_hip_yaw': {'lower': -0.52, 'upper': 0.52, 'damping': 1.0},\n        'left_hip_roll': {'lower': -0.52, 'upper': 0.52, 'damping': 1.0},\n        'left_hip_pitch': {'lower': -1.57, 'upper': 0.78, 'damping': 2.0},\n\n        # Knee joints\n        'left_knee': {'lower': 0.0, 'upper': 2.26, 'damping': 2.0},\n\n        # Ankle joints\n        'left_ankle_pitch': {'lower': -0.52, 'upper': 0.52, 'damping': 0.5},\n        'left_ankle_roll': {'lower': -0.52, 'upper': 0.52, 'damping': 0.5},\n\n        # Shoulder joints\n        'left_shoulder_pitch': {'lower': -2.09, 'upper': 2.09, 'damping': 0.5},\n        'left_shoulder_yaw': {'lower': -1.57, 'upper': 1.57, 'damping': 0.5},\n        'left_shoulder_roll': {'lower': -3.14, 'upper': 1.57, 'damping': 0.5},\n\n        # Elbow joints\n        'left_elbow': {'lower': 0.0, 'upper': 2.61, 'damping': 0.5}\n    }\n\n    for joint_name, config in joint_config.items():\n        joint_path = f\"{robot_prim_path}/{joint_name}\"\n        joint_prim = get_prim_at_path(joint_path)\n\n        if joint_prim:\n            # Set joint limits\n            physx_joint_api = PhysxSchema.PhysxJointAPI(joint_prim)\n            physx_joint_api.CreateLowerLimitAttr(config['lower'])\n            physx_joint_api.CreateUpperLimitAttr(config['upper'])\n\n            # Set damping\n            physx_joint_api.CreateJointLinearLimitAttr(config['damping'])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"environment-creation-for-humanoid-robots",children:"Environment Creation for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"basic-environment-setup",children:"Basic Environment Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def create_humanoid_training_environment():\n    """Create an environment suitable for humanoid robot training"""\n    world = World(stage_units_in_meters=1.0)\n\n    # Create ground plane\n    add_reference_to_stage(\n        get_assets_root_path() + "/Isaac/Environments/Grid/default_environment.usd",\n        "/World/defaultGround"\n    )\n\n    # Add varied terrain for locomotion training\n    create_varied_terrain("/World/Terrain")\n\n    # Add obstacles for navigation\n    create_obstacles("/World/Obstacles")\n\n    # Add interactive objects\n    create_interactive_objects("/World/Objects")\n\n    return world\n\ndef create_varied_terrain(terrain_path):\n    """Create terrain with different surfaces for humanoid training"""\n    # Flat ground\n    add_reference_to_stage(\n        get_assets_root_path() + "/Isaac/Environments/Grid/default_environment.usd",\n        f"{terrain_path}/FlatGround"\n    )\n\n    # Uneven terrain\n    add_reference_to_stage(\n        get_assets_root_path() + "/Isaac/Props/Obstacles/uneven_ground.usd",\n        f"{terrain_path}/UnevenGround"\n    )\n\n    # Stairs\n    add_reference_to_stage(\n        get_assets_root_path() + "/Isaac/Props/Obstacles/stairs.usd",\n        f"{terrain_path}/Stairs"\n    )\n\n    # Slopes\n    add_reference_to_stage(\n        get_assets_root_path() + "/Isaac/Props/Obstacles/slope.usd",\n        f"{terrain_path}/Slope"\n    )\n\ndef create_obstacles(obstacles_path):\n    """Create obstacles for humanoid navigation"""\n    obstacle_configs = [\n        {"type": "box", "position": [2, 0, 0.5]},\n        {"type": "cylinder", "position": [-2, 1, 0.5]},\n        {"type": "sphere", "position": [0, -2, 0.5]}\n    ]\n\n    for i, config in enumerate(obstacle_configs):\n        if config["type"] == "box":\n            add_reference_to_stage(\n                get_assets_root_path() + "/Isaac/Props/Obstacles/box.usd",\n                f"{obstacles_path}/Box_{i}"\n            )\n        elif config["type"] == "cylinder":\n            add_reference_to_stage(\n                get_assets_root_path() + "/Isaac/Props/Obstacles/cylinder.usd",\n                f"{obstacles_path}/Cylinder_{i}"\n            )\n        elif config["type"] == "sphere":\n            add_reference_to_stage(\n                get_assets_root_path() + "/Isaac/Props/Obstacles/sphere.usd",\n                f"{obstacles_path}/Sphere_{i}"\n            )\n'})}),"\n",(0,o.jsx)(e.h3,{id:"advanced-environment-features",children:"Advanced Environment Features"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class DynamicEnvironment:\n    def __init__(self, world):\n        self.world = world\n        self.movable_objects = []\n        self.dynamic_lights = []\n\n    def add_movable_object(self, usd_path, position, mass=1.0):\n        """Add a movable object to the environment"""\n        obj_path = f"/World/MovableObj_{len(self.movable_objects)}"\n\n        add_reference_to_stage(usd_path, obj_path)\n\n        # Set position\n        from omni.isaac.core.utils.prims import set_world_translation\n        set_world_translation(position, obj_path)\n\n        # Configure physics\n        obj_prim = get_prim_at_path(obj_path)\n        rigid_body_api = UsdPhysics.RigidBodyAPI.Apply(obj_prim)\n        rigid_body_api.CreateRigidBodyEnabledAttr(True)\n\n        # Set mass\n        mass_api = UsdPhysics.MassAPI.Apply(obj_prim)\n        mass_api.CreateMassAttr(mass)\n\n        self.movable_objects.append(obj_path)\n\n    def add_dynamic_lighting(self, position, intensity=1000):\n        """Add dynamic lighting that can be modified during simulation"""\n        light_path = f"/World/DynamicLight_{len(self.dynamic_lights)}"\n\n        # Create light prim\n        stage = omni.usd.get_context().get_stage()\n        light_prim = stage.DefinePrim(light_path, "DistantLight")\n        light_prim.GetAttribute("xformOp:translate").Set(position)\n        light_prim.GetAttribute("inputs:intensity").Set(intensity)\n\n        self.dynamic_lights.append(light_path)\n\n    def randomize_environment(self):\n        """Randomize environment properties for domain randomization"""\n        # Randomize object positions\n        for obj_path in self.movable_objects:\n            new_pos = [\n                random.uniform(-5, 5),\n                random.uniform(-5, 5),\n                random.uniform(0.5, 2.0)\n            ]\n            from omni.isaac.core.utils.prims import set_world_translation\n            set_world_translation(new_pos, obj_path)\n\n        # Randomize lighting\n        for light_path in self.dynamic_lights:\n            light_prim = get_prim_at_path(light_path)\n            new_intensity = random.uniform(500, 2000)\n            light_prim.GetAttribute("inputs:intensity").Set(new_intensity)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"sensor-integration-in-isaac-sim",children:"Sensor Integration in Isaac Sim"}),"\n",(0,o.jsx)(e.h3,{id:"camera-sensors",children:"Camera Sensors"}),"\n",(0,o.jsx)(e.p,{children:"Isaac Sim provides high-quality camera simulation with various configurations:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from omni.isaac.sensor import Camera\nimport numpy as np\n\nclass IsaacSimCamera:\n    def __init__(self, prim_path, config):\n        self.camera = Camera(\n            prim_path=prim_path,\n            frequency=config.get("frequency", 30),\n            resolution=(config["width"], config["height"])\n        )\n\n        # Configure camera intrinsic parameters\n        self.camera.focal_length = config.get("focal_length", 24.0)\n        self.camera.focus_distance = config.get("focus_distance", 10.0)\n        self.camera.f_stop = config.get("f_stop", 0.0)  # 0.0 = disabled\n\n        # Enable different sensor types\n        self.sensor_types = []\n        if config.get("rgb", True):\n            self.camera.add_render_product("rgb")\n            self.sensor_types.append("rgb")\n\n        if config.get("depth", False):\n            self.camera.add_render_product("depth")\n            self.sensor_types.append("depth")\n\n        if config.get("semantic", False):\n            self.camera.add_render_product("semantic_segmentation")\n            self.sensor_types.append("semantic")\n\n        if config.get("instance", False):\n            self.camera.add_render_product("instance_segmentation")\n            self.sensor_types.append("instance")\n\n    def get_observation(self):\n        """Get sensor observation data"""\n        observation = {}\n\n        if "rgb" in self.sensor_types:\n            observation["rgb"] = self.camera.get_rgb()\n\n        if "depth" in self.sensor_types:\n            observation["depth"] = self.camera.get_depth()\n\n        if "semantic" in self.sensor_types:\n            observation["semantic"] = self.camera.get_semantic_segmentation()\n\n        if "instance" in self.sensor_types:\n            observation["instance"] = self.camera.get_instance_segmentation()\n\n        return observation\n\n    def get_pose(self):\n        """Get camera pose in world coordinates"""\n        return self.camera.get_world_pose()\n\n# Example usage\ncamera_config = {\n    "width": 640,\n    "height": 480,\n    "frequency": 30,\n    "focal_length": 24.0,\n    "rgb": True,\n    "depth": True,\n    "semantic": True\n}\n\nhead_camera = IsaacSimCamera("/World/Robot/head_camera", camera_config)\n'})}),"\n",(0,o.jsx)(e.h3,{id:"lidar-and-other-sensors",children:"LIDAR and Other Sensors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'from omni.isaac.range_sensor import LidarRtx\n\nclass IsaacSimLidar:\n    def __init__(self, prim_path, config):\n        self.lidar = LidarRtx(\n            prim_path=prim_path,\n            translation=config.get("position", (0, 0, 0)),\n            orientation=config.get("orientation", (0, 0, 0, 1)),\n            config_file_name=config.get("config_file", "Example_Rotary_Lidar"),\n            # Custom configuration\n            rotation_frequency=config.get("rotation_freq", 10),\n            channels=config.get("channels", 16),\n            points_per_channel=config.get("points_per_channel", 1000),\n            horizontal_resolution=config.get("horizontal_resolution", 0.1875),\n            vertical_resolution=config.get("vertical_resolution", 2.0),\n            horizontal_laser_angle=config.get("horizontal_angle", 360.0),\n            vertical_laser_angle=config.get("vertical_angle", 30.0),\n            max_range=config.get("max_range", 25.0),\n            min_range=config.get("min_range", 0.1),\n        )\n\n    def get_point_cloud(self):\n        """Get 3D point cloud from LIDAR"""\n        return self.lidar.get_point_cloud()\n\n    def get_ranges(self):\n        """Get distance measurements"""\n        return self.lidar.get_linear_depth_data()\n\n    def get_pose(self):\n        """Get LIDAR pose"""\n        return self.lidar.get_world_pose()\n\n# Create LIDAR sensor for humanoid robot\nlidar_config = {\n    "position": (0, 0, 1.5),  # On robot\'s head\n    "channels": 32,\n    "points_per_channel": 2048,\n    "max_range": 25.0\n}\n\nrobot_lidar = IsaacSimLidar("/World/Robot/lidar", lidar_config)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"simulation-control-and-execution",children:"Simulation Control and Execution"}),"\n",(0,o.jsx)(e.h3,{id:"world-management",children:"World Management"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class IsaacSimWorldManager:\n    def __init__(self):\n        self.world = None\n        self.robots = []\n        self.sensors = []\n\n    def setup_world(self, stage_units_in_meters=1.0):\n        """Initialize the simulation world"""\n        self.world = World(stage_units_in_meters=stage_units_in_meters)\n\n        # Configure physics\n        physics_ctx = self.world.get_physics_context()\n        physics_ctx.set_gravity(9.81)\n        physics_ctx.set_simulation_dt(1.0/60.0, substeps=1)\n\n        # Enable GPU dynamics if available\n        try:\n            physics_ctx.enable_gpu_dynamics(True)\n            physics_ctx.set_broadphase_type("GPU")\n        except:\n            print("GPU dynamics not available, using CPU")\n\n        return self.world\n\n    def add_robot(self, robot):\n        """Add robot to the simulation"""\n        self.robots.append(robot)\n\n    def reset_world(self):\n        """Reset the entire simulation world"""\n        if self.world:\n            self.world.reset()\n\n            # Reset all robots\n            for robot in self.robots:\n                robot.reset()\n\n    def run_simulation(self, num_steps=1000, render=True):\n        """Run the simulation for specified steps"""\n        for step in range(num_steps):\n            # Update robots\n            for robot in self.robots:\n                robot.update()\n\n            # Step the physics simulation\n            self.world.step(render=render)\n\n            # Check for termination conditions\n            if self.check_termination():\n                break\n\n    def check_termination(self):\n        """Check if simulation should terminate"""\n        # Implement termination conditions\n        return False\n\n    def get_simulation_state(self):\n        """Get current state of the entire simulation"""\n        state = {\n            \'time\': self.world.current_time_step_index,\n            \'robots\': [robot.get_state() for robot in self.robots],\n            \'sensors\': [sensor.get_data() for sensor in self.sensors]\n        }\n        return state\n'})}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-simulation-features",children:"Humanoid-Specific Simulation Features"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class HumanoidSimulationController:\n    def __init__(self, world, robot):\n        self.world = world\n        self.robot = robot\n        self.balance_controller = BalanceController()\n        self.locomotion_controller = LocomotionController()\n\n    def setup_balance_control(self):\n        """Setup balance control for humanoid robot"""\n        # Initialize balance controller with robot parameters\n        self.balance_controller.initialize(\n            robot_mass=self.robot.get_mass(),\n            com_height=self.robot.get_com_height()\n        )\n\n    def apply_balance_control(self):\n        """Apply balance control to maintain humanoid stability"""\n        # Get current robot state\n        robot_state = self.robot.get_state()\n\n        # Calculate balance corrections\n        balance_corrections = self.balance_controller.compute_control(robot_state)\n\n        # Apply corrections to robot\n        self.robot.apply_joint_torques(balance_corrections)\n\n    def setup_locomotion(self, gait_type=\'walk\'):\n        """Setup locomotion controller for humanoid movement"""\n        self.locomotion_controller.setup_gait(gait_type)\n\n    def execute_locomotion_step(self):\n        """Execute one step of locomotion"""\n        # Get desired locomotion command\n        desired_velocity = self.locomotion_controller.get_desired_velocity()\n\n        # Generate joint trajectories\n        joint_trajectories = self.locomotion_controller.generate_trajectories(\n            self.robot.get_state(), desired_velocity\n        )\n\n        # Apply to robot\n        self.robot.set_joint_trajectories(joint_trajectories)\n\n    def run_humanoid_behavior(self, behavior_type):\n        """Run specific humanoid behavior"""\n        if behavior_type == \'walk\':\n            self.setup_locomotion(\'walk\')\n            self.execute_locomotion_step()\n            self.apply_balance_control()\n        elif behavior_type == \'balance\':\n            self.apply_balance_control()\n        elif behavior_type == \'manipulate\':\n            # Implement manipulation behavior\n            pass\n'})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices-for-isaac-sim",children:"Best Practices for Isaac Sim"}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def optimize_simulation_performance(world):\n    """Optimize Isaac Sim performance for humanoid applications"""\n\n    # Physics optimization\n    physics_ctx = world.get_physics_context()\n\n    # Use appropriate substeps for stability vs performance\n    physics_ctx.set_simulation_dt(1.0/60.0, substeps=2)\n\n    # Enable multithreading\n    physics_ctx.enable_multithreading(True)\n\n    # Use GPU dynamics if available\n    try:\n        physics_ctx.enable_gpu_dynamics(True)\n        physics_ctx.set_broadphase_type("GPU")\n    except:\n        pass  # GPU dynamics not available\n\n    # Rendering optimization\n    # Reduce resolution for training phases\n    # Use simpler materials and lighting\n    # Implement frustum culling for cameras\n\ndef setup_humanoid_simulation_optimally(robot_path):\n    """Setup humanoid simulation with optimal parameters"""\n\n    # Create world with appropriate units\n    world = World(stage_units_in_meters=1.0)\n\n    # Configure physics for humanoid stability\n    physics_ctx = world.get_physics_context()\n    physics_ctx.set_simulation_dt(1.0/120.0, substeps=2)  # Higher frequency for humanoid\n    physics_ctx.set_gravity(-9.81)\n\n    # Enable GPU dynamics for complex humanoid simulation\n    try:\n        physics_ctx.enable_gpu_dynamics(True)\n        physics_ctx.set_broadphase_type("GPU")\n    except:\n        print("Using CPU dynamics")\n\n    # Load robot with optimized parameters\n    robot = Robot(prim_path=robot_path)\n\n    return world, robot\n'})}),"\n",(0,o.jsx)(e.h3,{id:"model-quality-and-validation",children:"Model Quality and Validation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Use accurate mass properties for realistic physics"}),"\n",(0,o.jsx)(e.li,{children:"Implement proper joint limits and friction models"}),"\n",(0,o.jsx)(e.li,{children:"Validate simulation against real-world robot specifications"}),"\n",(0,o.jsx)(e.li,{children:"Test with various environmental conditions"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"physics-instability",children:"Physics Instability"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"def fix_physics_instability(robot_prim_path):\n    \"\"\"Fix common physics instability issues in humanoid robots\"\"\"\n\n    # Increase joint damping\n    for joint_name in ['hip', 'knee', 'ankle', 'shoulder', 'elbow']:\n        joint_path = f\"{robot_prim_path}/{joint_name}_joint\"\n        joint_prim = get_prim_at_path(joint_path)\n\n        if joint_prim:\n            physx_joint_api = PhysxSchema.PhysxJointAPI(joint_prim)\n            # Increase damping to stabilize joints\n            physx_joint_api.CreateJointLinearLimitAttr(2.0)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"rendering-performance",children:"Rendering Performance"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce resolution during training"}),"\n",(0,o.jsx)(e.li,{children:"Use simplified materials and lighting"}),"\n",(0,o.jsx)(e.li,{children:"Implement level-of-detail (LOD) systems"}),"\n",(0,o.jsx)(e.li,{children:"Use occlusion culling for large environments"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Isaac Sim provides a powerful platform for humanoid robotics simulation with high-fidelity physics and photorealistic rendering. Understanding the core architecture, proper configuration, and optimization techniques is essential for effective simulation. The combination of USD-based scene description, PhysX physics, and RTX rendering makes Isaac Sim ideal for developing and testing complex humanoid robot behaviors."}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Create a humanoid robot model in Isaac Sim with proper physics configuration"}),"\n",(0,o.jsx)(e.li,{children:"Implement a camera system with RGB, depth, and semantic segmentation"}),"\n",(0,o.jsx)(e.li,{children:"Set up a varied terrain environment for humanoid locomotion training"}),"\n",(0,o.jsx)(e.li,{children:"Optimize the simulation for real-time performance with a complex humanoid model"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,o.jsx)(e.p,{children:'[1] NVIDIA, "Isaac Sim Documentation," NVIDIA Corporation, 2023.'}),"\n",(0,o.jsx)(e.p,{children:'[2] NVIDIA, "Omniverse Platform Overview," NVIDIA Corporation, 2023.'}),"\n",(0,o.jsx)(e.p,{children:'[3] A. To et al., "Advanced Robotics Simulation with Isaac Sim," NVIDIA Technical Report, 2022.'})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);